<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Johngo Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/"/>
  <updated>2020-05-16T02:47:21.393Z</updated>
  <id>https://github.com/zhuangxq/zhuangxq.github.io.git/</id>
  
  <author>
    <name>Johngo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS面试总结</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2020/05/16/iOS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2020/05/16/iOS面试总结/</id>
    <published>2020-05-16T01:36:48.000Z</published>
    <updated>2020-05-16T02:47:21.393Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间去面了一次iOS。 那会整理了一些iOS面试题及答案，分享出来。答案基本是参考各路资料后给出自己的理解阐述。<br><a id="more"></a></p><h2 id="UI相关">UI相关</h2><h3 id="UIView与CALayer">UIView与CALayer</h3><p>UIView持有CALayer，UIView是CALayer的代理，CALayer负责渲染，UIView处理响应交互事件，参与响应链。</p><h3 id="事件传递与视图响应链">事件传递与视图响应链</h3><p><img src="/images/iOS面试总结/15825329182541.png" alt></p><h3 id="图像显示原理">图像显示原理</h3><p><img src="/images/iOS面试总结/15826102129502.png" alt></p><p><img src="/images/iOS面试总结/15826102310541.png" alt><br>CPU通过布局计算，输出位图，通过总线传递给GPU，GPU对位图进行图层渲染，然后把结果放到帧缓冲区，视频控制器按照VSync信号逐帧读取缓冲区数据。经过数模转换传递给显示器。</p><p><img src="/images/iOS面试总结/15831500493518.png" alt></p><ol><li>Commit Transaction:通过CPU创建绘制视图，提交会话，包括自己和子数的layout得状态，图片的解码和格式转换等等。</li><li>Render Server:解析提交的子树状态，生成绘制指令</li><li>GPU执行绘制指令，进行渲染。</li><li>显示渲染后的帧缓存的数据。</li></ol><p><img src="/images/iOS面试总结/15831501127060.png" alt><br>Commit Transaction：</p><ol><li>layout 布局</li><li>display 绘制阶段，例如drawRect、绘制string（字符串）</li><li>prepare 图片解码、图片格式转换</li><li>commit 提交位图</li></ol><p>GPU<br>顶点着色<br>图元装配<br>光栅华<br>片段着色<br>片段处理</p><p>参考链接：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p><h3 id="UI绘制流程">UI绘制流程</h3><p><img src="/images/iOS面试总结/15831494193600.png" alt></p><p><img src="/images/iOS面试总结/15827878024363.png" alt></p><h3 id="UI卡顿掉帧原因">UI卡顿掉帧原因</h3><p><img src="/images/iOS面试总结/15826101090438.jpg" alt><br>刷新频率每秒60帧，每帧16.7s。 一个VSync时间内，CPU和GPU没有完成一帧提交，则这一帧被丢弃，这时显示屏保留之前的内容。 这就是卡帧。</p><h3 id="滑动优化方案">滑动优化方案</h3><p>结构上：</p><ul><li>较复杂的feed Cell更细粒度，提高复用性</li><li>IGList</li></ul><p>CPU：</p><ul><li>对象创建尽量使用轻量代替重量，比如不需要交互可以用layer。耗时的创建任务可以放到子线程(UI除外)</li><li>减少对象调整，frame/bounds/transform等，可以一次做完的尽量一次做完。</li><li>ViewModel提前算布局，TimeFormat,Height，文本计算等。</li><li>减少图层、减少布局计算、不需要交互可以用layer、能到后台线程的操作就移到后台线程</li><li>图片的解码后台线程提前做。UIImage创建图片不会立即解码，提交到GPU要渲染时候才解码。可以用CGBitmapContext提前绘制解码。</li></ul><p>GPU：</p><ul><li>纹理渲染：减少短时间大量图片显示，多张图可以合成一张</li><li>视图混合：视图层级过于复杂，会消耗较多GPU。尽量减少图层数量和层次。不透明视图标明opaque属性避免无用alpha通道生成。</li><li>图形生成：减少CALayer的 border、圆角、阴影、遮罩（mask）操作。圆角可以盖图上去，或者图片直接处理成圆角图片。</li><li>阴影使用shadowPath</li><li>合理使用shouldRasterize</li></ul><p>内存：</p><ul><li>UILabel text仅在显示时设置值，hidden或者进入cell重用池，可以设置为nil。 Label显示文本会耗费较大内存。</li></ul><p>异步绘制：<br>    AsyncDisplayKit    </p><h3 id="离屏渲染">离屏渲染</h3><p>两种解释(意思差不多)：</p><ul><li><p>屏幕上显示内容，至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，也就是GPU渲染结果存放区域。如果由于一些限制，无法把渲染结果直接写入frame buffer，暂存在另外开辟的一个frame buffer，那么这个过程被称为离屏渲染。<br><img src="/images/iOS面试总结/15859682804661.jpg" alt></p></li><li><p>GPU在当前屏幕缓冲区以外再开一个缓冲区进行渲染操作。</p></li></ul><p>为什么会一个缓存区无法渲染完？<br>Render Server遵循<a href="https://zh.wikipedia.org/wiki/画家算法" target="_blank" rel="noopener">画家算法</a>, 画家算法简单讲就是由远及近的一层一层绘制，近的盖掉远的，且已经被盖住的层级就没法再修改了。圆角、阴影等可能没办法在一次遍历就绘出来，所以需要另外开一个缓冲区。</p><p>常见场景：</p><ul><li>cornerRadius+clipsToBounds</li><li>shadow layer本身还没渲染无法确定形状，所以需要再离屏渲染一次。但是如果指定了shadowPath，不需要依赖layer的渲染结果，就可以避免离屏渲染了。</li><li>group opacity</li><li>mask</li><li>UIBlurEffect</li><li>allowsEdgeAntialiasing</li></ul><p>性能影响</p><p>离屏渲染会造成GPU频繁切换上下文。GPU擅长大规模并行的重复操作，并擅长这种上下文切换。一旦发生离屏渲染，每秒60次上下文切换，性能损耗影响肯定不小了。</p><p>离屏渲染降低损耗<br>shouldRasterize开启，Render Server会强制把渲染结果缓存，下一帧还可以用。但是开启需要注意：</p><ul><li>shouldRasterize总会触发一次离屏渲染，如果本来没有离屏渲染，打开反而会造成离屏渲染。</li><li>缓存空间有限，不超过屏幕总像素2.5倍</li><li>缓存仅100ms，没有用自动丢弃</li><li>layer内容必须是静态的。一旦发生变化，缓存失效。</li><li>如果layer非常复杂，也可以利用这个缓存机制</li></ul><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72653360</a><br><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">https://www.jianshu.com/p/ca51c9d3575b</a></p><h3 id="CALayer的frame，bounds，anchorPoint,position">CALayer的frame，bounds，anchorPoint,position</h3><p>frame 相对于父坐标系的位置<br>bounds 相对于自身坐标系的位置<br>anchorPoint 锚点，作为旋转、缩放等空间变化提供中心点, 默认(0.5, 0.5)<br>position anchorPoint相对于superLayer坐标空间的位置</p><h3 id="iOS_为什么必须在主线程中操作UI">iOS 为什么必须在主线程中操作UI</h3><ul><li>UIKit 非线程安全。UI操作、渲染访问view的属性不安全。多线程同步操作容易有问题，比如tableView一个线程添加cell、一个线程删除cell。</li><li>绘制界面会在Main Runloop结束前统一绘制UI，如果有子线程修改UI，并不能及时同步到Main Runloop统一绘制。例：屏幕旋转重新布局，来不及全部布局，屏幕转过来了，UI可能还没布局好。</li><li>UIApplication在主线程初始化，交互事件由UIApplication处理，view的事件回调都在主线程。如果view可以在子线程操作，可能存在冲突，比如事件响应了，view同时在其他线程被移除操作。</li><li>UI绘制是从Application-&gt;Render Server-&gt;GPU, 是一个流线型渲染，如果有多线程，会有绘制不同步问题，前一帧修改hidden，下一帧修改text，不能统一绘制。且会频繁提交GPU渲染，资源浪费。</li></ul><p><a href="https://juejin.im/post/5c406d97e51d4552475fe178" target="_blank" rel="noopener">https://juejin.im/post/5c406d97e51d4552475fe178</a></p><h3 id="UIScrollView_原理">UIScrollView 原理</h3><p>UIView+Pangesture<br>修改自身的bounds，移动子view</p><h3 id="CATransaction是什么？">CATransaction是什么？</h3><p>CATransaction是Core Animation中的事务类，图层的每个修改都要事务的参与。CATransaction负责成批的把多个图层修改作为一个原子更新到渲染树。</p><h3 id="什么是隐式动画和显示动画，_什么时候会有隐式动画">什么是隐式动画和显示动画， 什么时候会有隐式动画</h3><p>隐式动画：CALayer设置可以动画的属性，系统会自动执行一个0.25s动画。<br>显示动画：自定义来指定动画，比如CAAniamtion、UIView的transitionFromView等</p><p>UIView默认layer的隐式动画关闭。<br>在animation block中UIView的隐式动画又重新开启。</p><h3 id="Auto_Layout的原理，性能如何">Auto Layout的原理，性能如何</h3><p>Auto Layout本质就是一个线性方程解析engin，将视图之间的关系表示为一个个线性方程，解析engin对线性方程组进行解析，求得方程组的解，也就是最终的frame。</p><p>完整Auto layout流程：<br>Layout Engin监听到约束变化(添加、删除等约束操作)，调用superview.setNeedLayout(), 进入约束容错处理(Deferred Layout pass)，如果有约束缺失冲突等，做容错处理。接下来会从上到下调用layoutSubviews()，通过<a href="https://constraints.cs.washington.edu/cassowary/" target="_blank" rel="noopener">Cassowary</a>算法计算出各个子视图的位置，算出来后视图的frame从Layout Engine里拷贝出来。再后面就是和手动布局一样。</p><p>性能：iOS 12 Auto Layout性能得到大幅优化，接近于frame布局。详见<a href="https://developer.apple.com/videos/play/wwdc2018/220" target="_blank" rel="noopener">WWDC 2018 Auto Layout</a></p><p>参考：<br><a href="https://time.geekbang.org/column/article/85332" target="_blank" rel="noopener">https://time.geekbang.org/column/article/85332</a></p><h3 id="drawRect_&amp;_layoutSubviews调用时机">drawRect &amp; layoutSubviews调用时机</h3><p>layoutSubviews：frame有变更<br>drawRect：view首次渲染出来；setNeedsDisplay</p><h3 id="图片是什么时候解码的，如何优化">图片是什么时候解码的，如何优化</h3><p>UIImage或CGImageSource创建图片不会立即解码图片，会在CALayer提交到GPU，CGImage中的数据才会得到解码，这一步发生在主线程，不可避免。 </p><p>优化：后台线程先把图片绘制到CGBitmapContext中，然后从Bitmap直接创建图片。</p><h3 id="图片渲染怎么优化">图片渲染怎么优化</h3><p>不知道.. 上题是一个优化。</p><h3 id="如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决">如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</h3><p>造成屏幕撕裂，前一帧还没显示完，下一帧的数据已经过来，两帧混在一起显示了。<br>通过垂直控制信号VSync，GPU等待显示器的VSync信号过来，才进行新的一帧渲染和缓冲区更新。</p><h2 id="多线程">多线程</h2><h3 id="iOS开发中有多少类型的线程？分别对比">iOS开发中有多少类型的线程？分别对比</h3><p><img src="/images/iOS面试总结/15836567672506.jpg" alt></p><p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#challenges-of-concurrent-programming" target="_blank" rel="noopener">https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#challenges-of-concurrent-programming</a></p><h3 id="GCD原理">GCD原理</h3><p><a href="https://bestswifter.com/deep-gcd/#dispatch_decl" target="_blank" rel="noopener">https://bestswifter.com/deep-gcd/#dispatch_decl</a><br><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#challenges-of-concurrent-programming" target="_blank" rel="noopener">https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#challenges-of-concurrent-programming</a></p><h3 id="GCD的优势体现在哪">GCD的优势体现在哪</h3><ul><li>更好用API</li><li>苹果称更充分的利用多核优势</li><li>更高的效率：开发只维护队列任务，不直接操作线程，GCD根据设备状态统一管理线程调度，底层是一个线程池，线程可复用。系统维护线程肯定优于程序员维护。</li></ul><h3 id="GCD有哪些队列，默认提供哪些队列">GCD有哪些队列，默认提供哪些队列</h3><p>串行队列（先进入队列的任务先出队列，每次只执行一个任务）<br>并发队列（依然是“先入先出”，不过可以形成多个任务并发）<br>主队列（这是一个特殊的串行队列，而且队列中的任务一定会在主线程中执行）</p><p>同步异步、串行并行和线程的关系</p><table><thead><tr><th></th><th style="text-align:center">同步</th><th style="text-align:center">异步</th></tr></thead><tbody><tr><td>主队列</td><td style="text-align:center">在主线程中执行</td><td style="text-align:center">在主线程中执行</td></tr><tr><td>串行队列</td><td style="text-align:center">在当前线程中执行</td><td style="text-align:center">新建线程执行</td></tr><tr><td>并发队列</td><td style="text-align:center">在当前线程中执行</td><td style="text-align:center">新建线程执行</td></tr></tbody></table><table><thead><tr><th></th><th style="text-align:center">NSOperationQueue</th><th style="text-align:center">GCD</th></tr></thead><tbody><tr><td>主队列</td><td style="text-align:center">NSOperationQueue.mainQueue</td><td style="text-align:center">dispatch_get_main_queue()</td></tr><tr><td>串行队列</td><td style="text-align:center">自建队列maxConcurrentOperationCount为1</td><td style="text-align:center">dispatch_queue_create(“”, DISPATCH_QUEUE_SERIAL)</td></tr><tr><td>并发队列</td><td style="text-align:center">自建队列maxConcurrentOperationCount大于1</td><td style="text-align:center">dispatch_queue_create(“”, DISPATCH_QUEUE_CONCURRENT)</td></tr></tbody></table><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局并发队列的优先级</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高优先级</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）优先级</span></span><br><span class="line"><span class="comment">//注意，自定义队列的优先级都是默认优先级</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低优先级</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台优先级</span></span><br></pre></td></tr></table></figure><p>更多GCD方法、同步异步队列多线程等看下面链接，写得很简洁易懂。<br>dispatch_set_target_queue: 设置优先级、设置几个串行队列target到同一个目标串行队列，可以同步执行。<br>dispatch_suspend和dispatch_resume<br>dispathc_once<br>dispatch_barrier_async<br>dispatch_semaphore</p><p><a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="noopener">https://bestswifter.com/multithreadconclusion/</a></p><h3 id="GCD主线程_&amp;_主队列的关系">GCD主线程 &amp; 主队列的关系</h3><p>主队列一定在主线程执行</p><h3 id="如何实现线程同步，有多少方式就说多少">如何实现线程同步，有多少方式就说多少</h3><ul><li>队列串行执行，避免同步问题</li><li>锁</li><li>信号量</li><li>dispatch_barrier_async</li></ul><p><a href="https://juejin.im/post/5d255fa6f265da1b5f267d49" target="_blank" rel="noopener">https://juejin.im/post/5d255fa6f265da1b5f267d49</a></p><h3 id="dispatch_once实现原理">dispatch_once实现原理</h3><p><img src="/images/iOS面试总结/15836674152232.png" alt><br>dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。<br><a href="https://xiaozhuanlan.com/topic/7916538240" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/7916538240</a></p><h3 id="什么情况下会死锁">什么情况下会死锁</h3><ul><li>dispatch_sync往当前队列添加任务</li><li>dispatch_once block内又触发走到该dispatch_once</li><li>其他多个线程在相互等待着对方的结束时，就会发生死锁</li></ul><h3 id="有哪些类型的线程锁，分别介绍下作用和使用场景">有哪些类型的线程锁，分别介绍下作用和使用场景</h3><ol><li>OSSpinLock 自旋锁，while忙等，效率高，耗CPU</li><li>os_unfair_lock 替代OSSpinLock，OSSpinLock有bug</li><li>pthread_mutex 互斥锁。线程会从sleep（加锁）——&gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。</li><li>dispatch_semaphore 信号量</li><li>NSLock NSLock是对pthread_mutex普通锁的封装</li><li>NSRecursiveLock 递归锁</li><li>NSCondition 条件锁</li><li>NSConditionLock 条件锁</li><li>@synchronized 使用了递归锁</li><li>pthread_rwlock 读写锁：没有写的锁，可以任意读。没有读写锁，才可以写。</li><li>dispatch_barrier_async</li><li>atomic <a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">原子操作</a> atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter就没保障了。比如：self.A = self.A + self.B，外面操作self.A已经不安全了。 还有 self.A = @”test”,  如果访问的是@”test”，也是不安全的。</li></ol><h3 id="NSOperationQueue中的maxConcurrentOperationCount默认值">NSOperationQueue中的maxConcurrentOperationCount默认值</h3><p>默认-1，根据系统当前状态，动态决定count</p><h3 id="NSTimer、CADisplayLink、dispatch_source_t_的优劣">NSTimer、CADisplayLink、dispatch_source_t 的优劣</h3><ul><li>CADisplayLink: 与屏幕刷新频率一样的刷新，精度高</li><li>NSTimer 精确度低一点，存在延时。需要加入runloop，所以会受runloop时间影响</li><li>dispatch_source_t 用起来麻烦点，精度可能在上面两个之间</li></ul><h3 id="多线程资源竞争为什么会崩溃">多线程资源竞争为什么会崩溃</h3><p><img src="/images/iOS面试总结/15870924781700.png" alt></p><p>在多线程程序中，非法指针的产生可能就没那么容易发现了。一般情况下，多个线程对共享的数据同时写，或者一写多读时，如果不加锁保证共享数据的同步访问，则会很容易导致数据访问冲突，继而引发非法指针、产生错误数据，甚至影响执行逻辑。</p><p>在iOS中 一个变量在获取新值之前要释放以前的旧址<br>在并行访问同一块资源的时候 如果释放了一次旧址 再次释放就会导致过度释放<br>过度释放会让程序崩溃 报BAD_ACCESS_ADDRESS</p><h2 id="内存管理">内存管理</h2><h3 id="内存区域分布">内存区域分布</h3><p>在iOS开发过程中，为了合理的分配有限的内存空间，将内存区域分为五个区，由低地址向高地址分类分别是：代码区、常量区、全局静态区、堆、栈。</p><ul><li>代码段 — 程序编译产生的二进制的数据</li><li>常量区 — 存储常量数据，通常程序结束后由系统自动释放</li><li>全局静态区 — 全局区又可分为未初始化全局区：.bss段和初始化全局区：data段。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，在程序结束后有系统释放。</li><li>堆（heap) — 程序运行过程中,动态分配的内存</li><li>栈（stack） — 存放局部变量，临时变量</li></ul><h3 id="weak的实现原理？">weak的实现原理？</h3><p> weak修饰对象存到hash表，weak指向到对象的内存地址作为key，weak修饰的变量的内存地址存到数组，数组作为value，若weak指向的对象引用计数为0，会以该对象的地址到表中搜索value，删除。</p><p> <a href="http://www.cocoachina.com/articles/18962" target="_blank" rel="noopener">http://www.cocoachina.com/articles/18962</a></p><h3 id="关联对象的应用？系统如何实现关联对象的">关联对象的应用？系统如何实现关联对象的</h3><p>分类中添加变量。<br>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的。一个对象对应一张Hash表，key值为对象地址，value为一个map表，这个map表维护具体的关联对象信息。<br><a href="https://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">https://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/</a></p><h3 id="关联对象的如何进行内存管理的？关联对象如何实现weak属性">关联对象的如何进行内存管理的？关联对象如何实现weak属性</h3><p>提供五种关联策略：OBJC_ASSOCIATION_ASSIGN、OBJC_ASSOCIATION_RETAIN_NONATOMIC、OBJC_ASSOCIATION_COPY_NONATOMIC、OBJC_ASSOCIATION_RETAIN、OBJC_ASSOCIATION_COPY</p><p>包一层strong对象即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakAssociatedObjectWrapper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakAssociatedObjectWrapper</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">ViewController</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIViewController</span> *vc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ViewController</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setVc:(<span class="built_in">UIViewController</span> *)vc &#123;</span><br><span class="line">    WeakAssociatedObjectWrapper *wrapper = [WeakAssociatedObjectWrapper new];</span><br><span class="line">    wrapper.object = vc;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vc), wrapper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)vc &#123;</span><br><span class="line">    WeakAssociatedObjectWrapper *wrapper = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">return</span> wrapper.object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>h<a href="https://zhangbuhuai.com/post/weak-associated-object.html" target="_blank" rel="noopener">https://zhangbuhuai.com/post/weak-associated-object.html</a></p><h3 id="Autoreleasepool的原理？所使用的的数据结构是什么">Autoreleasepool的原理？所使用的的数据结构是什么</h3><p>@autoreleasepool{}编译器改写如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure><p>这两个函数都是对AutoreleasePoolPage的封装，核心就是这个类实现。<br><img src="/images/iOS面试总结/15835985421733.jpg" alt></p><p>AutoreleasePoolPage是个双向链表，4096字节内存。一个page除了存这些固定变量外，其余空间用来存release对象。</p><ol><li>push就在page上面插入一个标记点</li><li>pop就从当前index到push的标记点，全部执行一遍release</li><li>index位置退到标记点</li><li>如果一页存满了就往下一个page存，释放的时候的时候还是一直往前找到push标记点。<br><img src="/images/iOS面试总结/15835987187831.jpg" alt></li></ol><p><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">https://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a></p><h3 id="为什么需要autoreleasePool">为什么需要autoreleasePool</h3><p><a href="https://tianxueweii.github.io/2019/01/13/关于AutoReleasePool和ARC的一些研究/" target="_blank" rel="noopener">https://tianxueweii.github.io/2019/01/13/关于AutoReleasePool和ARC的一些研究/</a></p><h3 id="ARC的实现原理？ARC下对retain_&amp;_release做了哪些优化">ARC的实现原理？ARC下对retain &amp; release做了哪些优化</h3><p>编译期自动插入用更底层的C接口实现retain/release/autorelease。引用计数。<br><a href="https://www.jianshu.com/p/7889e37dcba5" target="_blank" rel="noopener">https://www.jianshu.com/p/7889e37dcba5</a></p><h3 id="ARC下哪些情况会造成内存泄漏">ARC下哪些情况会造成内存泄漏</h3><p>循环引用： Block、timer、其他循环引用</p><h3 id="Clean,Dirty,Compression_Memory">Clean,Dirty,Compression Memory</h3><p>iOS中，内存分为两种，一种为Clean memory，另一种为Dirty memory；<br>Clean memory的page可以换出，既磁盘中有其对应内容，系统可以在内存紧张时将Clean memory的page换出，当再次访问时，可以重新从磁盘中读取，我们使用的图片、mapped files、Framework的数据段常量以及代码段等，这些都是Clean memory。<br>Dirty memory是无法换出的，我们所有的堆上的分配等都是属于Dirty memory,所以我们一定要尽可能的减少Dirty memory的使用。</p><p>从iOS7开始，iOS引入了Compression的概念，如下图为Instruments的Allocations template，我们可以从标红的地方看到，有一个Swapped Size的指标，从WWDC 2018 416得知，该指标的含义为compression size，即系统可以把最近最少使用的Dirty memory进行压缩，这样可以腾出一些pages供使用，当再次需要访问内容时，系统将其解压，这时，原来内容占多少pages，解压后同样会是相同数量的pages。</p><p><a href="https://zhongwuzw.github.io/2018/06/13/iOS内存管理之Swapped-Memory/" target="_blank" rel="noopener">https://zhongwuzw.github.io/2018/06/13/iOS内存管理之Swapped-Memory/</a></p><h2 id="Runloop">Runloop</h2><p>都来自大佬的文章：<br><a href="https://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/#base</a></p><h3 id="Runloop概念">Runloop概念</h3><p><img src="/images/iOS面试总结/15837660615027.png" alt><br>为了实现线程执行完不退出，可以休眠等待下次事件来，随时唤醒执行。类似执行逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p><p>提供两个对象：NSRunLoop 和 CFRunLoopRef。</p><h3 id="runloop与线程的关系">runloop与线程的关系</h3><p>线程与runloop一一对应，一个线程对应一个runloop。其关系保存在一个全局Dictionary里。线程刚创建不会有runloop，主动获取它才有。只能在线程内获取它的runloop，主线程除外。</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p><h3 id="Runloop内部逻辑">Runloop内部逻辑</h3><p><img src="/images/iOS面试总结/15860162415437.png" alt></p><h3 id="Runloop底层实现">Runloop底层实现</h3><p>RunLoop 的核心就是一个 mach_msg()，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p><p>详细看链接上面的内容。</p><h3 id="app如何接收到触摸事件的">app如何接收到触摸事件的</h3><p>苹果注册了一个source1(基于Mach port)来接收系统事件，回调函数为__IOHIDEventSystemClientQueueCallback。当硬件发生一个事件，IOKit.framework生成一个IOHIDEvent，SpringBoard接收事件，然后用Mach port转发给需要的App进程。随后注册的Source1就会触发回调，并调用_UIApplicationHandleEventQueue进行App内部分发。</p><h3 id="/images/iOS面试总结主线程的runloop是开启的">/images/iOS面试总结主线程的runloop是开启的</h3><p>主线程它需要啊，需要监听触摸事件、各种系统事件，需要添加autorelease，需要每个runloop去刷新UI。<br>子线程并没有相关需求。</p><h3 id="为什么只在主线程刷新UI">为什么只在主线程刷新UI</h3><ul><li>UIKit 非线程安全。UI操作、渲染访问view的属性不安全。多线程同步操作容易有问题，比如tableView一个线程添加cell、一个线程删除cell。</li><li>绘制界面会在Main Runloop结束前统一绘制UI，如果有子线程修改UI，并不能及时同步到Main Runloop统一绘制。例：屏幕旋转重新布局，来不及全部布局，屏幕转过来了，UI可能还没布局好。</li><li>UIApplication在主线程初始化，交互事件由UIApplication处理，view的事件回调都在主线程。如果view可以在子线程操作，可能存在冲突，比如事件响应了，view同时在其他线程被移除操作。</li><li>UI绘制是从Application-&gt;Render Server-&gt;GPU, 是一个流线型渲染，如果有多线程，会有绘制不同步问题，前一帧修改hidden，下一帧修改text，不能统一绘制。且会频繁提交GPU渲染，资源浪费。</li></ul><h3 id="PerformSelector和runloop的关系">PerformSelector和runloop的关系</h3><p>调用PerformSelector:afterDelay, 会创建一个Timer，并加入到当前线程的runloop中，如果没有runloop则不生效。<br>performSelector:OnThread:会创建一个Timmer加到对应线程的runloop。</p><h3 id="Runloop应用">Runloop应用</h3><p>AutoReleasePool<br>事件响应<br>手势识别<br>界面更新<br>定时器<br>PerformSelector<br>GCD<br>网络请求</p><h3 id="如何使线程保活">如何使线程保活</h3><p>添加一个runloop，runloop注册一个NSMachPort端口监听，runloop跑起来。<br>runloop实际上在do while循环，相当于线程就不会执行完，所以不会被销毁。如果要停止，需要remove端口监听。</p><h1 id="Objective-C_语言基础">Objective-C 语言基础</h1><h3 id="Category_的实现原理，以及_Category_为什么只能加方法不能加属性？">Category 的实现原理，以及 Category 为什么只能加方法不能加属性？</h3><p><a href="https://www.jianshu.com/p/8aa63f7e98d1" target="_blank" rel="noopener">https://www.jianshu.com/p/8aa63f7e98d1</a></p><h3 id="PerformSelector_NSInvocation优劣对比">PerformSelector  NSInvocation优劣对比</h3><p>performSelector简单，只能传一个参数<br>NSInvocation可以传多个参数，更完整，使用也更复杂</p><h3 id="KVO原理">KVO原理</h3><p>isa被替换成另一个类NSKVONotifying_A(isa-swizzling)，该类继承原来的类，重载setXX方法，添加willChange、didChange实现监听。</p><h3 id="取消系统默认的KVO">取消系统默认的KVO</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_name!=name) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">        _name=name;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哪些情况下使用kvo会崩溃，怎么防护崩溃">哪些情况下使用kvo会崩溃，怎么防护崩溃</h3><ol><li>KVO 添加次数和移除次数不匹配：<ul><li>移除了未注册的观察者，导致崩溃。</li><li>重复移除多次，移除次数多于添加次数，导致崩溃。</li><li>重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。</li></ul></li><li>被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。例如：被观察者是局部变量的情况（iOS 10 及之前会崩溃）。</li><li>添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 方法，导致崩溃。</li><li>添加或者移除时 keypath == nil，导致崩溃。</li></ol><h2 id="Block">Block</h2><h3 id="什么是Block？">什么是Block？</h3><p>C语言的功能扩充：带有局部变量的匿名函数，匿名函数就是不带名称的函数</p><h3 id="block的内部实现，结构体是什么样的">block的内部实现，结构体是什么样的</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    int32_t reserved;</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译时，会把block定义成结构体，结构体会包含截获的变量，block里面会的代码会抽成一个C函数，block持有该函数指针。执行block时就是执行该函数指针，结构体地址当参数传入。</p><p><a href="https://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="noopener">https://blog.ibireme.com/2013/11/27/objc-block/</a></p><h3 id="block是类吗，有哪些类型">block是类吗，有哪些类型</h3><p>是类，block结构体上有isa指针，就是oc上类的定义。<br>主要三种类型：<br>NSConcreteStackBlock     栈上创建的block<br>_NSConcreteMallocBlock  堆上创建的block<br>_NSConcreteGlobalBlock   作为全局变量的block<br><img src="/images/iOS面试总结/15837688025330.jpg" alt></p><h3 id="一个int变量被___block_修饰与否的区别？block的变量截获">一个int变量被 __block 修饰与否的区别？block的变量截获</h3><p> <strong>block修饰，在block内可以修改。<br>没有</strong>block修饰：值引用，声明一个int，赋值过来。<br>有__block修复：指针引用，直接引用该int变量的地址，生成一个结构体Block_byref含有该变量。</p><h3 id="block在修改NSMutableArray，需不需要添加__block">block在修改NSMutableArray，需不需要添加__block</h3><p>不用。修改array的内容不用，如果是直接改array变量，是要加__block</p><h3 id="怎么进行内存管理的">怎么进行内存管理的</h3><p>同普通变量ARC管理一样</p><h3 id="block可以用strong修饰吗">block可以用strong修饰吗</h3><p>可以<br><img src="/images/iOS面试总结/15837692317574.jpg" alt></p><h3 id="解决循环引用时为什么要用strong、weak修饰">解决循环引用时为什么要用<strong>strong、</strong>weak修饰</h3><p><strong>weak是为了解决循环引用。<br>block里面在</strong>strong引用，是为了避免block还没执行完，__weak引用的对象已经被释放了。</p><h3 id="block发生copy时机">block发生copy时机</h3><p><img src="/images/iOS面试总结/15837698122011.jpg" alt></p><h3 id="Block访问对象类型的auto(局部)变量时，在ARC和MRC下有什么区别">Block访问对象类型的auto(局部)变量时，在ARC和MRC下有什么区别</h3><p>MRC 环境下，block 截获外部用 <strong>block 修饰的变量，不会增加对象的引用计数<br>ARC 环境下，block 截获外部用 </strong>block 修饰的变量，会增加对象的引用计数<br>所以，在 MRC 环境下，可以通过 <strong>block 来打破循环引用，在 ARC 环境下，则需要用 </strong>weak 来打破循环引用。</p><p><img src="/images/iOS面试总结/15837720049081.jpg" alt></p><p>ARC无效时，__block说明符被用来避免Block中的循环引用。</p><h3 id="Block属性为什么要用Copy？">Block属性为什么要用Copy？</h3><h2 id="参考题目">参考题目</h2><h3 id="好好看看">好好看看</h3><p><a href="https://github.com/liberalisman/iOS-InterviewQuestion-collection">https://github.com/liberalisman/iOS-InterviewQuestion-collection</a><br><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md">https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647766057&amp;idx=2&amp;sn=81a8a4fc99b981b27fdb5360fefaedc0&amp;chksm=8887cf16bff04600d666a91b9500877694ccfa8279c66906692bbd91ed689493c79d11096700&amp;mpshare=1&amp;scene=1&amp;srcid=02280o6H5RQgLt9wORa7fdw0&amp;sharer_sharetime=1582874701213&amp;sharer_shareid=03e6ce94a5d32a3f844bec3fc56f0cda&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647766057&amp;idx=2&amp;sn=81a8a4fc99b981b27fdb5360fefaedc0&amp;chksm=8887cf16bff04600d666a91b9500877694ccfa8279c66906692bbd91ed689493c79d11096700&amp;mpshare=1&amp;scene=1&amp;srcid=02280o6H5RQgLt9wORa7fdw0&amp;sharer_sharetime=1582874701213&amp;sharer_shareid=03e6ce94a5d32a3f844bec3fc56f0cda&amp;rd2werd=1#wechat_redirect</a></p><p><a href="https://www.jianshu.com/p/d884f3040fda" target="_blank" rel="noopener">https://www.jianshu.com/p/d884f3040fda</a><br><a href="https://juejin.im/post/5d8484476fb9a06b2b47b263" target="_blank" rel="noopener">https://juejin.im/post/5d8484476fb9a06b2b47b263</a><br><a href="https://github.com/huihut/interview#-cc">https://github.com/huihut/interview#-cc</a></p><h3 id="稍微看下即可">稍微看下即可</h3><p><a href="https://www.jianshu.com/p/f4aab14b3f3a" target="_blank" rel="noopener">https://www.jianshu.com/p/f4aab14b3f3a</a><br><a href="https://www.zhihu.com/question/19604641" target="_blank" rel="noopener">https://www.zhihu.com/question/19604641</a><br><a href="https://hit-alibaba.github.io/interview/" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/</a><br><a href="https://juejin.im/post/5cd681826fb9a031fe3be3b2" target="_blank" rel="noopener">https://juejin.im/post/5cd681826fb9a031fe3be3b2</a><br><a href="https://juejin.im/post/5d7f35976fb9a06b20059680" target="_blank" rel="noopener">https://juejin.im/post/5d7f35976fb9a06b20059680</a><br><a href="http://www.cocoachina.com/articles/21331" target="_blank" rel="noopener">http://www.cocoachina.com/articles/21331</a><br><a href="https://dayon.gitbooks.io/-ios/content/chapter8.html" target="_blank" rel="noopener">https://dayon.gitbooks.io/-ios/content/chapter8.html</a><br><a href="https://cloud.tencent.com/developer/article/1387915" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1387915</a><br><a href="https://segmentfault.com/a/1190000018209983" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018209983</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间去面了一次iOS。 那会整理了一些iOS面试题及答案，分享出来。答案基本是参考各路资料后给出自己的理解阐述。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/iOS/"/>
    
      <category term="面试" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》笔记一 自动引用计数</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2020/02/03/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2020/02/03/自动引用计数/</id>
    <published>2020-02-03T08:58:08.000Z</published>
    <updated>2020-02-03T09:34:27.760Z</updated>
    
    <content type="html"><![CDATA[<p>前言，久仰《Objective-C高级编程 iOS与OS X多线程和内存管理》这本书大名，趁着放假学习一下。主要内容有三块：自动引用计数、Blocks、GCD。内容不多，但是讲得比较深入，且是iOS基础知识，值得详细阅读。本文为自动引用部分的一些笔记。</p><a id="more"></a><h4 id="引用计数">引用计数</h4><p>alloc创建, retain持有, release释放, dealloc废弃，一个对象创建并持有+1，持有+1，release-1，引用计数为0时dealloc。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建且持有对象</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得对象，但自己不持有</span></span><br><span class="line"><span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有持有，所以不能释放</span></span><br><span class="line">[array release]; <span class="comment">// 会蹦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 持有对象</span></span><br><span class="line">[array <span class="keyword">retain</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持有对象了，需要释放</span></span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure><p>[NSMutableArray array]为什么创建的对象存在，但是没有持有呢？因为里面调了autorelase</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)array &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数采用散列表来管理引用计数<br><img src="/images/自动引用计数/15806399286271.jpg" alt></p><h4 id="autorelease_实现">autorelease 实现</h4><p>autorelease可以使对象在超出指定的生存范围时能够自动并正确地释放(调用release方法)。<br><img src="/images/自动引用计数/15736159643763.jpg" alt></p><p>autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">    [<span class="built_in">NSAutoReleasePool</span> addObject:<span class="keyword">self</span>]; <span class="comment">//实际这个方法是有IMP缓存，去掉查找过程，直接执行的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj &#123;</span><br><span class="line">    <span class="built_in">NSAutoReleasePool</span> *pool = 取得正在使用的<span class="built_in">NSAutoReleasePool</span>对象;</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [pool addOjbect:anObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSAutoReleasePool对象非存在状态下调用autorelease"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj &#123;</span><br><span class="line">    [array addObject:anObj];    <span class="comment">// 内部数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drain &#123;</span><br><span class="line">    [<span class="keyword">self</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> emptyPool];</span><br><span class="line">    [array release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)emptyPool &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line">        [obj release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是GNUStep的autorelease实现，苹果的具体实现是形式不太一样，C++实现，流程本质是一样的。</p><h4 id="ARC">ARC</h4><p>ARC有效时，其类型上必须附加所有权修饰符。总共四个所有权修饰符：</p><ul><li>__strong：默认修饰符</li><li>__weak</li><li>__unsafe_unretained</li><li>__autoreleasing</li></ul><h5 id="__strong">__strong</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ARC有效</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// __strong修饰符的变量objc在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象</span></span><br><span class="line">   <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC无效</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">   [obj release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strong修饰符表示对对象的“强引用”。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。且，在赋值上也能够正确的管理其对象的所有者，赋新值，旧值犹如超出作用域一样，会被释放。还有一个情况，对象废弃，对象所属的成员变量也会废弃。 通过</strong>strong修饰符，不必再次键入retain或者release。</p><h5 id="__weak">__weak</h5><p><strong>strong互相引用的时候，会出现循环引用，导致无法释放。</strong>weak提供弱引用，弱引用不能持有对象的实例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自己生成并持有对象</span></span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// objc1 变量持有生成对象的弱引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  因为obj0变量超出其作用域，强引用失效，所以自动释放自己持有的对象。</span></span><br><span class="line">    <span class="comment">// objc1没有持有。对象的所有者不存在，所以废弃该对象。</span></span><br></pre></td></tr></table></figure><p>__weak还有另一优点。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。</p><h5 id="__unsafe_unretained">__unsafe_unretained</h5><p>正如其名，这个是不安全的所有权修饰符。同__weak一样，是不持有对象的。但是引用的对象如果不存在了，不会置空变量，导致野指针。现在都不需要使用这个修饰符了。</p><h5 id="__autoreleasing">__autoreleasing</h5><p>ARC有效时，用@autoreleasepool块替代NSAutoReleasePool类，用附有__autoreleasing修饰符的变量替代autorelease方法。<br><img src="/images/自动引用计数/15790743058541.jpg" alt></p><p>通常不需要显示的写<strong>autoreleasing，就像不会显式地使用 </strong>strong修饰符一样。</p><ol><li>编译器会检查方法名是否以alloc, new, copy, mutableCopy 开始，如果不是则自动将返回值的对象注册到 autoreleasepool 中；</li><li>虽然<strong>weak 修饰符是为了避免强引用循环（strong reference circle）而使用的，但在访问附有 </strong>weak 修饰符的变量时，实际上必定要访问注册到 autoreleasepool 的对象。因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象过程中，该对象有可能被废弃。而将弱引用对象注册到 autoreleasepool 中，在 pool 被销毁之前都能确保该对象存在。</li><li>id 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上__autoreleasing 修饰符。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)stringWithContentsOfURL:(<span class="built_in">NSURL</span> *)url encoding:(<span class="built_in">NSStringEncoding</span>)enc error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)stringWithContentsOfURL:(<span class="built_in">NSURL</span> *)url encoding:(<span class="built_in">NSStringEncoding</span>)enc error:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br></pre></td></tr></table></figure><h4 id="ARC规则">ARC规则</h4><ul><li>不能使用retain/release/retainCount/autorelease</li><li>不能使用NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不要显示调用dealloc</li><li>使用@autoreleasepool 代替NSAutoreleasePool</li><li>不能使用区域NSZone</li><li>对象类型不能作为C语言结构体(struc/union)的成员</li><li>显示转换”id”和”void*”</li></ul><h5 id="显示转换”id”和”void*”">显示转换”id”和”void*”</h5><p>ARC无效时直接转换，ARC有效须通过bridge转。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC无效</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj;</span><br><span class="line"><span class="keyword">id</span> o = p;</span><br><span class="line">[o release];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC有效</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span>*)obj;  <span class="comment">// 安全性与赋值给__unsafe_unretained修饰符相近，甚至更低</span></span><br><span class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure><p><strong>bridge另外提供两种转换, </strong>bridge_retained和<strong>bridge_transfer转换。</strong>bridge_retainer可使要转换赋值的变量也持有所辅助的对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC无效</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj;</span><br><span class="line">[(<span class="keyword">id</span>)p <span class="keyword">retain</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC有效</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    p = (__bridge_retainer <span class="keyword">void</span>*)obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// obj失效，p还持有对象，所以不被释放</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>__bridge_transfer转换提供相反的动作，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC无效</span></span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p;</span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line">[(<span class="keyword">id</span>)p release];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC有效</span></span><br><span class="line"><span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure><h5 id="Objective-C对象和Core_Foundation对象之间的相互变换">Objective-C对象和Core Foundation对象之间的相互变换</h5><p>可使用方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFTypeRef</span> X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_transfer <span class="keyword">id</span>)X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ARC实现">ARC实现</h4><h5 id="__strong修饰符">__strong修饰符</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure><p>由此可知，ARC有效时，编译器自动插入release。下面看看非alloc/new/copy/mutableCopy的方法会怎样？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSArray</span> array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSArray</span>, <span class="keyword">@selector</span>(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj);</span><br><span class="line">objc_release(obj);</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) array &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line">+ (<span class="keyword">id</span>) array &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSArray</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">    objc_msgSend(obj, <span class="keyword">@selector</span>(init));</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleasedReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_autoreleasedReturnValue和objc_retainAutoreleasedReturnValue这两个是成对的，主要用于程序优化，省去注册到autoreleasePool的过程。</p><p>objc_autoreleasedReturnValue用于类似array这种类方法的返回对象实现上。objc_autoreleasedReturnValue会检查使用该函数的方法或函数调用方的执行命令列表，如果调用方调用了方法或函数后紧接着调用objc_retainAutoreleasedReturnValue，则不会将返回的对象注册到autoreleasePool，而是直接传到方法或函数的调用方。没有紧接该函数，则注册到autoreleasePool。</p><p><img src="/images/自动引用计数/15806374729341.jpg" alt></p><h5 id="__weak修饰符">__weak修饰符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 假设obj是__strong修饰且赋过值</span><br><span class="line">    id __weak objc1 = obj;</span><br><span class="line">    </span><br><span class="line">    // 编译器模拟代码</span><br><span class="line">    id obj1;</span><br><span class="line">    objc_initWeak(&amp;obj1, obj);</span><br><span class="line">    objc_destroyWeak(&amp;obj1);</span><br><span class="line">    </span><br><span class="line">    // objc_initWeak方法实际如下：</span><br><span class="line">    // 先将obj1赋0，再通过storeWeak方法赋值</span><br><span class="line">    obj1 = 0;</span><br><span class="line">    objc_storeWeak(&amp;obj1, obj);</span><br><span class="line">    </span><br><span class="line">    // objc_destroyWeak方法实际如下：</span><br><span class="line">    objc_storeWeak(&amp;obj1, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_storeWeak函数把第二参数的赋值对象的地址作为键值，将第一参数的附有<strong>weak修饰符的变量的地址注册到weak表中。如果第二参数为0，则把变量的地址从weak表中删除。<br>weak表与引用计数表相同，作为散列表被实现。如果使用weak表，将废弃对象的地址作为键值检索，就能高速地获取对应的附有</strong>weak修饰符的变量的地址。另外，由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址。</p><p>废弃谁都不持有的对象，具体是如何实现的？对象通过objc_release函数释放过程</p><ol><li>objc_release</li><li>引用计数为0，调用dealloc</li><li>_objc_rootDealloc</li><li>object_dispose</li><li>objc_destructInstance</li><li>objc_clear_deallocating</li></ol><p>objc_clear_deallocating函数的具体动作如下：</p><ol><li>从weak表中获取废弃对象的地址为键值的记录</li><li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li><li>从weak表中删除该记录</li><li>从引用计数表中删除废弃对象的地址为键值的记录</li></ol><p>以上步骤说明了<strong>weak修饰符的变量所引用的对象被废弃，则将nil赋值给该变量这一功能的实现。大量使用</strong>weak，会消耗CPU资源。</p><h5 id="autoreleaseing">autoreleaseing</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器模拟代码</span></span><br><span class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();</span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(objc, <span class="keyword">@selector</span>(init));</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure><h5 id="引用计数-1">引用计数</h5><p>_objc_rootRetainCount(id obj) 统计引用计数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言，久仰《Objective-C高级编程 iOS与OS X多线程和内存管理》这本书大名，趁着放假学习一下。主要内容有三块：自动引用计数、Blocks、GCD。内容不多，但是讲得比较深入，且是iOS基础知识，值得详细阅读。本文为自动引用部分的一些笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>川滇藏翻山越岭之旅</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2019/10/27/%E5%B7%9D%E6%BB%87%E8%97%8F%E7%BF%BB%E5%B1%B1%E8%B6%8A%E5%B2%AD%E4%B9%8B%E6%97%85/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2019/10/27/川滇藏翻山越岭之旅/</id>
    <published>2019-10-27T09:10:40.000Z</published>
    <updated>2020-02-03T16:28:30.559Z</updated>
    
    <content type="html"><![CDATA[<p>最近几年，每年国庆都出去玩，去了几个地方都没有什么记录。今年突然想记录下，于是想起了几年前搭的blog，没写什么东西，草倒是长满了。顺便，也给blog垦垦荒。</p><p>对于从小生活在南方，山俊水秀又靠海，然而都是丘陵，总显得有点“小气”，打心底是有点向往西北的广袤壮阔。所以之前去了青海、新疆，今年国庆又走了四川、云南、西藏。漫漫长路，翻山越岭，让我们出发咯。</p><h3 id="行程准备">行程准备</h3><p>大概八月跟小伙伴定下来要走川藏线，成都到拉萨，于是一个多月，陆陆续续做准备。去年我们在新疆，自驾了近三千公里，环北疆一大圈，翻过独库公路。所以这次毫无疑问，也是继续自驾。自驾的好处无需多言，自由，没有行程约束，甚至可以走哪算哪，当然也可以体验下驾驶的乐趣😆。租车对比多家，最终在淘宝订了一辆丰田普拉多，2.7L排量，10天13000人民币。主要是异地还车费贵，成都借拉萨还特别贵。毕竟大家都是进藏的路线。路线我们订了个大概行程，成都-&gt;稻城-&gt;德钦(梅里雪山)-&gt;G214-&gt;G318-&gt;拉萨，由于没确定在稻城要花多少时间，所以稻城后面每天到哪具体行程都没定，反正走到哪算哪都没问题。</p><p>我们在网上买了好多好多吃的，直接寄到成都的酒店，省去了自己搬运。租车的大哥跟我们强调了一些注意事项，关于车的一些使用注意项，路况的注意事项，不要跟藏民有冲突之类的~~反正，路上真的要小心就对了。高原不是开玩笑，前不着村后不着店的地方多了去。</p><a id="more"></a><h3 id="进高原的一些注意事项">进高原的一些注意事项</h3><p>第一，高原缺氧，要注意高反，到高原前两天一定不要洗澡，洗澡血液循环加快，需氧量更多，供不上氧容易晕。第一天我们到雅江，忍不住洗了下，真的有点晕，心律加快，好在缓过来了。刚到高原不要剧烈运动，当自己是个老人比较安全。红景天我感觉用处不大，更多可能是心理安慰。还有要保持心态放松，不要慌，没高反都自己紧张出高反了。最后切记不要冒然挑战别人总结的经验。</p><p>第二，高原昼夜温差大，保暖要做好，高原感冒很危险，可能引发肺水肿，准备出发的前几天一个小伙伴感冒了，直接退出了…说好不鸽还是鸽了。</p><p>第三，高原湿度较低，要带好保湿用品，水乳、唇膏等。唇膏一定要带，嘴唇干裂起来非常难受，进了高原地带，这东西不好买了。身体乳需要的话也可以带，之前从新疆回来，身体好多地方都脱皮了。</p><p>第四，防晒。高原紫外线辐射强，比平原强很多很多。防晒霜，帽子，太阳镜都要。</p><h3 id="Day_1_成都-雅江">Day 1 成都-雅江</h3><p>早上成都出发，中午到康定，晚上到雅江。由于前一天晚上很晚到成都，早上又直接出发了，没有在成都逛吃真是遗憾，下次再来。早上我开的开车，大部分是高速，普拉多开起来并不是很舒服，第一次开这么大的车还需要适应哈哈。中午在康定吃了个川菜，贼香，无图，还在这里收了一张违停的罚单，就停了没几分钟。。。</p><p>出了康定往沿着318再爬一会山，来到折多山，景色还不错，上图！<br><img src="/images/川滇藏翻山越岭之旅/day1_1.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day1_2.JPG" alt></p><p>这个折多山海拔已经4000多了，这个观景台爬上去太耗体了，刚上到这个高度还在喘气，就没上去了。过了折多山，一路翻山越岭，都是往返两车道，大车也比较多，开呀开，到六点多到了雅江。见识了下山里的小城，真的挺小的。山谷里建起来的小县城。</p><p><img src="/images/川滇藏翻山越岭之旅/day1_3.jpg" alt></p><p>雅江人民的娱乐生活<br><img src="/images/川滇藏翻山越岭之旅/day1_4.jpg" alt></p><p>晚上又吃了一顿美味的火锅，一定要加松茸，雅江是松茸之乡，真的好好吃~~ 酒足饭饱。</p><h3 id="Day_2_雅江-稻城亚丁">Day 2 雅江-稻城亚丁</h3><p>路途遥远，一路都在开车，到稻城的路上有一些小景色，都没看了，直奔稻城的香格里拉镇。中午在理塘吃了一顿普通的川菜，味道中规中矩还行吧。晚上又吃了一顿美好的火锅，真香。当地特色菌菇，松茸还是很好吃~~很饱很饱。<br><img src="/images/川滇藏翻山越岭之旅/day2_1.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day2_2.jpg" alt></p><p>吃完去镇上买了第二天登山的登山杖、氧气瓶，准备了第二天要带的口粮。</p><h3 id="Day_3_稻城亚丁景区一日游">Day 3 稻城亚丁景区一日游</h3><p>稻城亚丁的攻略非常多，不做过多介绍，我会简单介绍下线路还有注意事项。先看一张网上的路线图<br><img src="/images/川滇藏翻山越岭之旅/day3_1.jpg" alt></p><p>一般分长线和短线，短线到珍珠海，不到一天可以游完。长线是到牛奶海和五色海，正常满满一天才能游完。我们一天时间选择长线，长线的知名度也更高，不到牛奶海和五色海不好意思说到过稻城亚丁吧。</p><p>我们从酒店自驾到亚丁景区门口，那里有地下停车场，还挺方便的。买完票进去搭景区的区间车，翻了一个多小时的山路，到扎灌崩，再徒步一小段到冲古寺做电瓶车到洛绒牛场。到这个地方正常要10来点了。牛场景色还挺好看的，也可以看到雪山了。</p><p><img src="/images/川滇藏翻山越岭之旅/day3_2.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_3.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_4.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_5.jpg" alt></p><p>亚丁三座雪山，是藏人心中的神山——仙乃日，意思是四臂观音；夏诺多吉，意思是金刚手菩萨；央迈勇，文殊菩萨。三座雪山合起来，称作“三怙主”，据说莲花生大师为三座雪山开过光，并以三大菩萨的名字命名。</p><p>从牛场这里开始就是要徒步了，上山可以骑马，但也只是一段比较平的路，但是在高原上这一段路其实可以省很多体力，能骑上马的建议骑马。但是排的人很多，一定要早到才坐得到。不然排到了可能你都自己走到了。我们到的时候人很多，就走路出发了。海拔4000徒步真的很累人，而且我们也没做多少徒步的心理准备。登山杖建议还是带一个，可以节省体力。</p><p>一路美景<br><img src="/images/川滇藏翻山越岭之旅/day3_6.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_7.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_8.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_9.jpg" alt></p><p>一路走走停停，快13点到牛奶海, 已经累的不行，不过看到这景色，还是值得的。</p><p><img src="/images/川滇藏翻山越岭之旅/day3_10.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_11.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_12.jpg" alt></p><p>牛奶海再往上走一段，到五色海，比牛奶海逊色一些，也可能是天气已经有点不太好，看不太出效果。</p><p><img src="/images/川滇藏翻山越岭之旅/day3_13.jpg" alt></p><p><img src="/images/川滇藏翻山越岭之旅/day3_14.jpg" alt></p><p>最后留一张稻城的纪念照<br><img src="/images/川滇藏翻山越岭之旅/day3_15.jpg" alt></p><p>再补充一些tip，先到牛奶海再到五色海，如果直接到五色海会爬一段很抖的坡，这会体力已经快不行了。13点多要准备下山了，走回去还要好久，要赶最后一趟电瓶车和区间车。注意关注下最后班次的时间！</p><h3 id="Day_4_稻城-梅里雪山">Day 4 稻城-梅里雪山</h3><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几年，每年国庆都出去玩，去了几个地方都没有什么记录。今年突然想记录下，于是想起了几年前搭的blog，没写什么东西，草倒是长满了。顺便，也给blog垦垦荒。&lt;/p&gt;
&lt;p&gt;对于从小生活在南方，山俊水秀又靠海，然而都是丘陵，总显得有点“小气”，打心底是有点向往西北的广袤壮阔。所以之前去了青海、新疆，今年国庆又走了四川、云南、西藏。漫漫长路，翻山越岭，让我们出发咯。&lt;/p&gt;
&lt;h3 id=&quot;行程准备&quot;&gt;行程准备&lt;/h3&gt;&lt;p&gt;大概八月跟小伙伴定下来要走川藏线，成都到拉萨，于是一个多月，陆陆续续做准备。去年我们在新疆，自驾了近三千公里，环北疆一大圈，翻过独库公路。所以这次毫无疑问，也是继续自驾。自驾的好处无需多言，自由，没有行程约束，甚至可以走哪算哪，当然也可以体验下驾驶的乐趣😆。租车对比多家，最终在淘宝订了一辆丰田普拉多，2.7L排量，10天13000人民币。主要是异地还车费贵，成都借拉萨还特别贵。毕竟大家都是进藏的路线。路线我们订了个大概行程，成都-&amp;gt;稻城-&amp;gt;德钦(梅里雪山)-&amp;gt;G214-&amp;gt;G318-&amp;gt;拉萨，由于没确定在稻城要花多少时间，所以稻城后面每天到哪具体行程都没定，反正走到哪算哪都没问题。&lt;/p&gt;
&lt;p&gt;我们在网上买了好多好多吃的，直接寄到成都的酒店，省去了自己搬运。租车的大哥跟我们强调了一些注意事项，关于车的一些使用注意项，路况的注意事项，不要跟藏民有冲突之类的~~反正，路上真的要小心就对了。高原不是开玩笑，前不着村后不着店的地方多了去。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking源码阅读笔记之二--AFURLRequestSerialization/AFURLResponseSerialization</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2016/07/02/AFNetworking%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E4%BA%8C-AFURLRequestSerialization-AFURLResponseSerialization/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2016/07/02/AFNetworking源码阅读之二-AFURLRequestSerialization-AFURLResponseSerialization/</id>
    <published>2016-07-02T07:56:23.000Z</published>
    <updated>2019-10-27T08:25:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>继续AFNetworking笔记。本篇主要关于NSURLRequest的生成，请求回来响应的处理。</p><a id="more"></a><h2 id="AFHTTPRequestSerializer">AFHTTPRequestSerializer</h2><p>AFHTTPRequestSerializer是生成NSURLRequest核心类。它有两个子类AFJSONRequestSerializer、AFPropertyListRequestSerializer，分别对应不同的参数生成方式。生成request方法：</p><pre><code>- (<span class="type">NSMutableURLRequest</span> *)requestWithMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span>                                 <span class="type">URLString</span>:(<span class="type">NSString</span> *)<span class="type">URLString</span>                                parameters:(id)parameters                                     error:(<span class="type">NSError</span> *__autoreleasing *)error{    <span class="type">NSParameterAssert</span>(<span class="keyword">method</span>);    <span class="type">NSParameterAssert</span>(<span class="type">URLString</span>);    <span class="type">NSURL</span> *url = [<span class="type">NSURL</span> <span class="type">URLWithString</span>:<span class="type">URLString</span>];    <span class="type">NSParameterAssert</span>(url);    <span class="type">NSMutableURLRequest</span> *mutableRequest = [[<span class="type">NSMutableURLRequest</span> alloc] initWithURL:url];    mutableRequest.<span class="type">HTTPMethod</span> = <span class="keyword">method</span>;    <span class="keyword">for</span> (<span class="type">NSString</span> *keyPath <span class="keyword">in</span> <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>()) { <span class="comment">#1</span>        <span class="keyword">if</span> ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {  <span class="comment">#1</span>            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath]; <span class="comment">#1</span>        }    }    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];  <span class="comment">#2</span>    <span class="keyword">return</span> mutableRequest;}</code></pre><p>该方法创建一个新NSMutableRequest，#1部分是在设置一些请求配置，如allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies等。这些配置的设置通过KVO观察，有设置值，则存到self.mutableObservedChangedKeyPaths，再把这些值通过KVC设置到NSMutableRequest。这个方式值得借鉴，简便明了。#2部分则是调用设置请求参数的方法，这是个AFURLRequestSerialization协议方法。接下来看下AFHTTPRequestSerializer对这个方法的实现（下面所有代码都会有略去一些非关键代码）：</p><pre><code>- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request                               withParameters:(<span class="keyword">id</span>)parameters                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error{    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;    <span class="keyword">if</span> (parameters) {        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queryStringSerialization</span>) {  <span class="comment">//一个block，参数生成的方法外包出去了，给外部自行实现。</span>            <span class="built_in">NSError</span> *serializationError;            query = <span class="keyword">self</span><span class="variable">.queryStringSerialization</span>(request, parameters, &amp;serializationError);            <span class="keyword">if</span> (serializationError) {                <span class="keyword">if</span> (error) {                    *error = serializationError;                }                <span class="keyword">return</span> <span class="literal">nil</span>;            }        } <span class="keyword">else</span> {            <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.queryStringSerializationStyle</span>) {                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle: <span class="comment">//默认参数生成方法,类似这样：ver=1.3.0&amp;idfa=<span class="doctag"><span class="keyword">xxx</span></span></span>                    query = AFQueryStringFromParameters(parameters);                    <span class="keyword">break</span>;            }        }    }    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> containsObject:[[request HTTPMethod] uppercaseString]]) {    <span class="comment">//如果请求方式是 GET,HEAD,DELETE, 则将参数接到URL后面</span>        <span class="keyword">if</span> (query &amp;&amp; query<span class="variable">.length</span> &gt; <span class="number">0</span>) {            mutableRequest<span class="variable">.URL</span> = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest<span class="variable">.URL</span> absoluteString] stringByAppendingFormat:mutableRequest<span class="variable">.URL</span><span class="variable">.query</span> ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];        }    } <span class="keyword">else</span> {    <span class="comment">//POST方法</span>        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span>        <span class="keyword">if</span> (!query) {            query = <span class="string">@""</span>;        }        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) {            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];        }        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>]];<span class="comment">//设置HTTPBody</span>    }    <span class="keyword">return</span> mutableRequest;}</code></pre><p>生成NSURLRequest大致如此，AFJSONRequestSerializer对应的参数生成方法：[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]， AFPropertyListRequestSerializer对应的参数生成方法：[NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]。 如果参数有自己比较特殊结构，可以仿AFJSONRequestSerializer，实现协议方法，自定义生成方式。</p><h3 id="分块数据上传">分块数据上传</h3><p>AFHTTPRequestSerializer这个类还有个比较重要的功能，就是实现分块数据上传的功能。分块上传是什么东西？我们知道HTTP分为三部分：状态行，请求头，请求体。主要数据一般放请求体，请求体却只有一个。那如何实现多块数据上传？答案很简单，就是多块数据按照一定格式拼成一块，并且多块数据间有分隔符，请求方需要告诉响应方当前请求是个分块数据和分割符长啥样。先看下如何用这个功能。</p><pre><code>AFHTTPSessionManager *session = [AFHTTPSessionManager manager];[session <span class="string">POST:</span>@<span class="string">"https://api.app.net/stream/0/posts/stream/global"</span> <span class="string">parameters:</span>nil <span class="string">constructingBodyWithBlock:</span>^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) {    NSData *data1 = [@<span class="string">"我是multipart data part111"</span> <span class="string">dataUsingEncoding:</span>NSUTF8StringEncoding];    NSData *data2 = [@<span class="string">"我是multipart data part222"</span> <span class="string">dataUsingEncoding:</span>NSUTF8StringEncoding];    NSData *data3 = [@<span class="string">"我是multipart data part333"</span> <span class="string">dataUsingEncoding:</span>NSUTF8StringEncoding];    [formData <span class="string">appendPartWithFormData:</span>data1 <span class="string">name:</span>@<span class="string">"11111"</span>];    [formData <span class="string">appendPartWithFormData:</span>data2 <span class="string">name:</span>@<span class="string">"22222"</span>];    [formData <span class="string">appendPartWithFormData:</span>data3 <span class="string">name:</span>@<span class="string">"33333"</span>];} <span class="string">progress:</span>^(NSProgress * _Nonnull uploadProgress) {} <span class="string">success:</span>^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {    NSLog(@<span class="string">"success:%@"</span>, responseObject);} <span class="string">failure:</span>^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {    NSLog(@<span class="string">"failed:%@"</span>, error);}];</code></pre><p>这个与正常的请求相比多了constructingBodyWithBlock，这个block就是用来添加分块数据。再看看这个请求，最终的HTTP请求长什么样。</p><p><img src="/images/af_multipart_2.png" alt><br><img src="/images/af_multipart_3.png" alt></p><p>看请求头的Content-Type:multipart/form-data; boundary=Boundary+7C0ABF26A3C30CEB。这是分块上传必须有的一个header，告诉响应方当前是分块数据，且分割线为Boundary+7C0ABF26A3C30CEB，响应方据此处理。由于分割线肯定不能跟数据块有一样的情况，所以分割线一般是一个随机复杂较长的值。接着看请求体，去掉分割线，就剩下三段数据，每段数据由Content-Disposition、空行、数据组成，<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html" target="_blank" rel="noopener">Content-Disposition</a>官方释义：The Content-Disposition response-header field has been proposed as a means for the origin server to suggest a default filename if the user requests that the content is saved to a file. 就是如果这块数据是要被保存成文件，那么Content-Disposition这个header就可以提供默认名。可以知道，其实分块数据请求其实就是POST请求，只不过在请求体数据做文章而已。下面的内容，都是围绕如何生成这个最终的请求体数据在做文章。</p><p>看相关的几个类：</p><p><img src="/images/afnet_multipart.png" alt></p><p>AFStreamingMultipart总管分块数据的生成模块，AFMultipartBodyStream是一个数据流，AFHTTPBodyPart是具体的每个数据块的内容。AFMultipartFormData提供各种各样数据(string,data,file,stream…)的添加接口。下面看muiltipart请求如何生成(省略非关键代码):</p><pre><code>- (<span class="type">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span>                                              <span class="type">URLString</span>:(<span class="type">NSString</span> *)<span class="type">URLString</span>                                             parameters:(<span class="type">NSDictionary</span> *)parameters                              constructingBodyWithBlock:(<span class="type">void</span> (^)(id &lt;<span class="type">AFMultipartFormData</span>&gt; formData))<span class="keyword">block</span>                                                  error:(<span class="type">NSError</span> *__autoreleasing *)error{    <span class="type">NSMutableURLRequest</span> *mutableRequest = [self requestWithMethod:<span class="keyword">method</span> <span class="type">URLString</span>:<span class="type">URLString</span> parameters:<span class="keyword">nil</span> error:error];    __block <span class="type">AFStreamingMultipartFormData</span> *formData = [[<span class="type">AFStreamingMultipartFormData</span> alloc] initWithURLRequest:mutableRequest stringEncoding:<span class="type">NSUTF8StringEncoding</span>];    <span class="keyword">if</span> (parameters) {        ...parameters转成data当成一个数据块添加到formData...        [formData appendPartWithFormData:data name:[pair.field description]];    }    //添加数据块    <span class="keyword">if</span> (<span class="keyword">block</span>) {        <span class="keyword">block</span>(formData);    }    //将已添加的数据块拼装成最终形式，返回。    <span class="keyword">return</span> [formData requestByFinalizingMultipartFormData];}</code></pre><p>数据块如何添加，举个文件如何添加的例子：</p><pre><code>- (<span class="built_in">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL                         name:(<span class="built_in">NSString</span> *)name                     fileName:(<span class="built_in">NSString</span> *)fileName                     mimeType:(<span class="built_in">NSString</span> *)mimeType                        error:(<span class="built_in">NSError</span> * __autoreleasing *)error{    ...判断参数是否正确，file是否存在...    <span class="built_in">NSDictionary</span> *fileAttributes = [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:[fileURL path] error:error];    <span class="keyword">if</span> (!fileAttributes) {        <span class="keyword">return</span> <span class="literal">NO</span>;    }    <span class="comment">//设置这个数据块的header，Content-Dispositon和Content-Type。Content-Type指的是这块数据的类型。</span>    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\"; filename=\"%@\""</span>, name, fileName] forKey:<span class="string">@"Content-Disposition"</span>];    [mutableHeaders setValue:mimeType forKey:<span class="string">@"Content-Type"</span>];    <span class="comment">//描述这个数据块的类，有header,boundary,stringEncoding,length等基本信息，body就是存数据的内容，类型为id，可以放各种各样数据，这里放文件URL。最终会通过流读出数据。</span>    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];    bodyPart<span class="variable">.stringEncoding</span> = <span class="keyword">self</span><span class="variable">.stringEncoding</span>;    bodyPart<span class="variable">.headers</span> = mutableHeaders;    bodyPart<span class="variable">.boundary</span> = <span class="keyword">self</span><span class="variable">.boundary</span>;    bodyPart<span class="variable">.body</span> = fileURL;    bodyPart<span class="variable">.bodyContentLength</span> = [fileAttributes[<span class="built_in">NSFileSize</span>] unsignedLongLongValue];    <span class="comment">//单个数据块添加到整个数据块中</span>    [<span class="keyword">self</span><span class="variable">.bodyStream</span> appendHTTPBodyPart:bodyPart];    <span class="keyword">return</span> <span class="literal">YES</span>;}</code></pre><p>其他数据类型添加大同小异，不再赘述。</p><p>数据块添加完，再看各个数据块如何拼装成最后的请求体。</p><pre><code>- (NSMutableURLRequest *)requestByFinalizingMultipartFormData {    // Reset the initial and final boundaries <span class="keyword">to</span> ensure correct Content-Length    [<span class="literal">self</span>.bodyStream <span class="built_in">set</span>InitialAndFinalBoundaries];    [<span class="literal">self</span>.request <span class="built_in">set</span>HTTPBodyStream:<span class="literal">self</span>.bodyStream];    [<span class="literal">self</span>.request <span class="built_in">set</span>Value:[NSString stringWithFormat:@<span class="string">"multipart/form-data; boundary=%@"</span>, <span class="literal">self</span>.boundary] <span class="keyword">for</span>HTTPHeaderField:@<span class="string">"Content-Type"</span>];    [<span class="literal">self</span>.request <span class="built_in">set</span>Value:[NSString stringWithFormat:@<span class="string">"%llu"</span>, [<span class="literal">self</span>.bodyStream contentLength]] <span class="keyword">for</span>HTTPHeaderField:@<span class="string">"Content-Length"</span>];    return <span class="literal">self</span>.request;}</code></pre><p>这里主要关心[self.request setHTTPBodyStream:self.bodyStream]， 其他代码好懂。这个设置后，HTTPBody请被置空，这个流的完整数据将被作为请求体。这个流需要是还没打开的，request会接管这个流，请求时候会打开，不用我们调流的open。关于流可以补一下<a href="http://southpeak.github.io/blog/2014/07/17/ioszhong-liu-stream-de-shi-yong/" target="_blank" rel="noopener">这篇</a>，stackoverflow看到个比较一针见血的描述：The thing you need to understand about NSStreams, is “don’t call us, we’ll call you.” When the stream has data available, it will notify its delegate, and then you read whatever data is available and tell it to go get some more. 然而也有主动call you的情况，AFHTTPBodyPart就是这样干的。</p><p>下面看流是如何读的，下面是AFMultipartBodyStream的代理方法：</p><pre><code>- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer        maxLength:(<span class="built_in">NSUInteger</span>)length{    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;    <span class="comment">//遍历每个AFHTTPBodyPart，有数据就读，没数据就跳到下一块</span>    <span class="keyword">while</span> ((<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead &lt; MIN(length, <span class="keyword">self</span><span class="variable">.numberOfBytesInPacket</span>)) {        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.currentHTTPBodyPart</span> || ![<span class="keyword">self</span><span class="variable">.currentHTTPBodyPart</span> hasBytesAvailable]) {            <span class="keyword">if</span> (!(<span class="keyword">self</span><span class="variable">.currentHTTPBodyPart</span> = [<span class="keyword">self</span><span class="variable">.HTTPBodyPartEnumerator</span> nextObject])) {                <span class="keyword">break</span>;            }        } <span class="keyword">else</span> {            <span class="built_in">NSUInteger</span> maxLength = MIN(length, <span class="keyword">self</span><span class="variable">.numberOfBytesInPacket</span>) - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead;            <span class="comment">//读取当前bodyPart的流。</span>            <span class="built_in">NSInteger</span> numberOfBytesRead = [<span class="keyword">self</span><span class="variable">.currentHTTPBodyPart</span> read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength];            <span class="keyword">if</span> (numberOfBytesRead == -<span class="number">1</span>) {                <span class="keyword">self</span><span class="variable">.streamError</span> = <span class="keyword">self</span><span class="variable">.currentHTTPBodyPart</span><span class="variable">.inputStream</span><span class="variable">.streamError</span>;                <span class="keyword">break</span>;            } <span class="keyword">else</span> {                totalNumberOfBytesRead += numberOfBytesRead;                <span class="comment">//每个数据块读完设延时，如果有的话，避免"request body stream exhausted"，默认无delay。</span>                <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.delay</span> &gt; <span class="number">0.0</span>f) {                    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="keyword">self</span><span class="variable">.delay</span>];                }            }        }    }    <span class="keyword">return</span> totalNumberOfBytesRead;}</code></pre><p>AFHTTPBodyPart的流读取方法：</p><pre><code>- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer        maxLength:(<span class="built_in">NSUInteger</span>)length{    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;    <span class="comment">//_phase表示当前处于数据块的哪块内容，边界线、header或者数据正文。。</span>    <span class="comment">//读取起始分割符或者中间的分割符</span>    <span class="keyword">if</span> (_phase == AFEncapsulationBoundaryPhase) {        <span class="built_in">NSData</span> *encapsulationBoundaryData = [([<span class="keyword">self</span> hasInitialBoundary] ? AFMultipartFormInitialBoundary(<span class="keyword">self</span><span class="variable">.boundary</span>) : AFMultipartFormEncapsulationBoundary(<span class="keyword">self</span><span class="variable">.boundary</span>)) dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>];        <span class="comment">//将data读到buffer，并且跳转到下一个_phase</span>        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];    }    <span class="comment">//读取header数据</span>    <span class="keyword">if</span> (_phase == AFHeaderPhase) {        <span class="comment">//将data读到buffer，并且跳转到下一个_phase</span>        <span class="built_in">NSData</span> *headersData = [[<span class="keyword">self</span> stringForHeaders] dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>];        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];    }    <span class="comment">//读取数据正文</span>    <span class="keyword">if</span> (_phase == AFBodyPhase) {        <span class="built_in">NSInteger</span> numberOfBytesRead = <span class="number">0</span>;        <span class="comment">//这个数据正文inputStream就是主动去read.</span>        numberOfBytesRead = [<span class="keyword">self</span><span class="variable">.inputStream</span> read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];        <span class="keyword">if</span> (numberOfBytesRead == -<span class="number">1</span>) {            <span class="keyword">return</span> -<span class="number">1</span>;        } <span class="keyword">else</span> {            totalNumberOfBytesRead += numberOfBytesRead;            <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.inputStream</span> streamStatus] &gt;= <span class="built_in">NSStreamStatusAtEnd</span>) {                [<span class="keyword">self</span> transitionToNextPhase];            }        }    }    <span class="comment">//判断是否是最后一个数据块，是的话加上分割符</span>    <span class="keyword">if</span> (_phase == AFFinalBoundaryPhase) {        <span class="built_in">NSData</span> *closingBoundaryData = ([<span class="keyword">self</span> hasFinalBoundary] ? [AFMultipartFormFinalBoundary(<span class="keyword">self</span><span class="variable">.boundary</span>) dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>] : [<span class="built_in">NSData</span> data]);        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];    }    <span class="keyword">return</span> totalNumberOfBytesRead;}</code></pre><p>以上就是分块数据上传的内容。读完源码，发现然而从来没用过这个功能- -。避免知识用到方恨少时，看看也是值得的。</p><h2 id="AFURLResponseSerialization">AFURLResponseSerialization</h2><p>请求的响应则单纯的多，比较简单，无非就是状态判断，MIME判断，不同类型数据的处理。</p><p><img src="/images/af_response.png" alt></p><p>基类AFHTTPResponseSerializer实现数据是否有效的校验，数据不做处理，原样返回data。几个子类则有对应的数据处理方法，值得一提的是JSON数据有帮我们做了一些空字段处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续AFNetworking笔记。本篇主要关于NSURLRequest的生成，请求回来响应的处理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking源码阅读笔记之一</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2016/06/25/AFNetworking%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2016/06/25/AFNetworking源码阅读笔记之一/</id>
    <published>2016-06-25T02:03:40.000Z</published>
    <updated>2019-10-27T08:25:22.873Z</updated>
    
    <content type="html"><![CDATA[<p>学习<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>前，最好先了解下<a href="http://objccn.io/issue-5-4/" target="_blank" rel="noopener">NSURLSession</a>。本文先介绍一下AFNetworking如何工作，整体结构是怎样的。先看架构图：</p><p><img src="/images/AFSummary.png" alt></p><p>AFURLSessionManager为核心类，类似于MVC中的controller，负责组织起整个工作流程，这里它要管的有AFHTTPRequestSerializer请求的生成，AFHTTPResponseSerializer响应处理的生成，NSURLSession的管理，请求task的各种各样回调处理，AFSecurityPolicy安全策略配置、缓存策略配置等。下面通过一个普通GET请求函数调用栈，了解下整套流程，分三部分：请求前、请求中、请求后。</p><a id="more"></a><p>请求前(in main queue)：</p><pre><code>[AFHTTPSessionManager <span class="string">GET:</span><span class="string">parameters:</span><span class="string">progress:</span><span class="string">success:</span><span class="string">failure:</span>]  [AFHTTPSessionManager <span class="string">dataTaskWithHTTPMethod:</span><span class="string">URLString:</span><span class="string">parameters:</span><span class="string">uploadProgress:</span><span class="string">downloadProgress:</span><span class="string">success:</span><span class="string">failure:</span>]    [AFHTTPRequestSerializer <span class="string">requestWithMethod:</span><span class="string">URLString:</span><span class="string">parameters:</span><span class="string">error:</span>]   #<span class="number">1</span>    [AFHTTPRequestSerializer <span class="string">requestBySerializingRequest:</span><span class="string">withParameters:</span><span class="string">error:</span>] #<span class="number">1</span>    [AFURLSessionManager <span class="string">dataTaskWithRequest:</span><span class="string">uploadProgress:</span><span class="string">downloadProgress:</span><span class="string">completionHandler:</span>]  #<span class="number">2</span>        [AFURLSessionManager <span class="string">addDelegateForDataTask:</span><span class="string">uploadProgress:</span><span class="string">downloadProgress:</span><span class="string">completionHandler:</span>]          [AFURLSessionManager <span class="string">setDelegate:</span><span class="string">forTask:</span>]        [AFURLSessionManager <span class="string">addNotificationObserverForTask:</span>]  [task resume]  #<span class="number">3</span></code></pre><p>AFHTTPSessionManager是AFURLSessionManager的子类，提供更方便的接口。#1是根据URL、请求参数生成NSMutableURLRequest，生成工作由AFHTTPRequestSerializer来做。#2就是创建NSURLSessionDataTask，同时也做了一些代理添加设置(代理、回调block管理下面讲)。#3[task resume]请求正式开始。</p><p>请求中(not in main thread)：</p><pre><code>[AFURLSessionManager <span class="string">URLSession:</span><span class="string">didReceiveChallenge:</span><span class="string">completionHandler:</span>] #<span class="number">1</span>    [AFSecurityPolicy <span class="string">evaluateServerTrust:</span><span class="string">forDomain:</span>] #<span class="number">1</span>        AFServerTrustIsValid  #<span class="number">1</span>[AFURLSessionManager <span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveData:</span>] #<span class="number">2</span>    [AFURLSessionManagerTaskDelegate <span class="string">URLSession:</span><span class="string">dataTask:</span><span class="string">didReceiveData:</span>] #<span class="number">3</span>[AFURLSessionManager <span class="string">URLSession:</span><span class="string">task:</span><span class="string">didCompleteWithError:</span>] #<span class="number">4</span>[AFURLSessionManagerTaskDelegate <span class="string">URLSession:</span><span class="string">task:</span><span class="string">didCompleteWithError:</span>] #<span class="number">4</span>[AFURLSessionManager <span class="string">removeDelegateForTask:</span>]</code></pre><p>第一个小部分#1是https的证书校验(明年肯定是都要https了…),这部分内容准备另外写一篇。#2就是数据接收。#3的AFURLSessionManagerTaskDelegate是代理管理的一个类，下面单独讲。 #4数据接收完成，请求结束，有错误就响应错误，没错误就去处理数据。</p><p>请求后(in queue: com.alamofire.networking.session.manager.processing)：</p><pre><code>[AFJSONResponseSerializer <span class="string">responseObjectForResponse:</span><span class="string">data:</span><span class="string">error:</span>]    [AFHTTPResponseSerializer <span class="string">validateResponse:</span><span class="string">data:</span><span class="string">error:</span>]</code></pre><p>请求后这俩就是数据的校验和数据的处理。AFJSONResponseSerializer继承自AFHTTPResponseSerializer,处理JSON数据。数据处理完，回主线程，success(failure) block回调。流程结束。</p><p>下面看下上面提到的AFURLSessionManagerTaskDelegate，代理回调、block都是怎么处理的？请求前#2有个addDelegate函数：</p><pre><code>- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask                uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock              downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler{    <span class="comment">//创建代理管理对象，并将三个block交给这个对象。</span>    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];    delegate<span class="variable">.manager</span> = <span class="keyword">self</span>;    <span class="comment">//持有AFURLSessionManager</span>    delegate<span class="variable">.completionHandler</span> = completionHandler;    dataTask<span class="variable">.taskDescription</span> = <span class="keyword">self</span><span class="variable">.taskDescriptionForSessionTasks</span>;    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];    delegate<span class="variable">.uploadProgressBlock</span> = uploadProgressBlock;    delegate<span class="variable">.downloadProgressBlock</span> = downloadProgressBlock;}- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate            forTask:(<span class="built_in">NSURLSessionTask</span> *)task{    <span class="built_in">NSParameterAssert</span>(task);    <span class="built_in">NSParameterAssert</span>(delegate);    [<span class="keyword">self</span><span class="variable">.lock</span> lock];    <span class="comment">//task和delegate manager以键值对方式存在这个字典。</span>    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span>[@(task<span class="variable">.taskIdentifier</span>)] = delegate;    [delegate setupProgressForTask:task];    <span class="comment">//进度回调设置，用KVO观察task的几个进度值。</span>    [<span class="keyword">self</span> addNotificationObserverForTask:task];    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];}</code></pre><p>从上面代码可以看出，AFURLSessionManager的进度回调和完成completionHandle都是交给了这个代理管理类。再看下这个类的@interface。</p><pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManagerTaskDelegate</span> : <span class="title">NSObject</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLSessionDownloadDelegate</span>&gt;</span><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) AFURLSessionManager *manager;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *mutableData;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *uploadProgress;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSProgress</span> *downloadProgress;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *downloadFileURL;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock uploadProgressBlock;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskProgressBlock downloadProgressBlock;<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskCompletionHandler completionHandler;<span class="keyword">@end</span></code></pre><p>可见主要的回调数据都交给了这个类，包括回调data，下载的fileURL。这个类实现了三个协议的三个方法，分别是数据接收didReceiveData，请求完成didCompleteWithError， 下载完成didFinishDownloadingToURL。所以这个类接管了进度和完成回调，处理了回调数据，最后完成block也在此。这里三个协议方法，仅仅就是提供三个方法而已,NSURLSession相关的代理并不是直接回调这三函数，这三函数是在AFURLSessionManager中的代理中调用。换句话，这三方法你随便换个名字也没啥问题，就是个普通方法。这里容易混淆。</p><p>另外，这里为什么要把进度、回调数据、数据处理这块单独拆出来？个人瞎以为：这样类的职能更清晰，AFURLSessionManager就是做网络请求的事，请求进度管理、请求回来的后事就是交给AFURLSessionManagerTaskDelegate，拆开的一个好处就是可拓展性增强，想要替换或者增加一个后事处理类型就比较容易了。不过也想不出这里还需要扩展出什么东西，或者也仅仅只是想做个代码拆分而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;前，最好先了解下&lt;a href=&quot;http://objccn.io/issue-5-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NSURLSession&lt;/a&gt;。本文先介绍一下AFNetworking如何工作，整体结构是怎样的。先看架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/AFSummary.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;AFURLSessionManager为核心类，类似于MVC中的controller，负责组织起整个工作流程，这里它要管的有AFHTTPRequestSerializer请求的生成，AFHTTPResponseSerializer响应处理的生成，NSURLSession的管理，请求task的各种各样回调处理，AFSecurityPolicy安全策略配置、缓存策略配置等。下面通过一个普通GET请求函数调用栈，了解下整套流程，分三部分：请求前、请求中、请求后。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AFNetworking" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>Masonry源码学习</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2016/03/24/Masonry%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2016/03/24/Masonry学习/</id>
    <published>2016-03-24T12:33:49.000Z</published>
    <updated>2019-10-27T08:25:55.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2><p>Masonry已经是离不开的开发库了，所有布局都用它，记录一下<a href="https://github.com/SnapKit/Masonry">Masonary</a>的源码学习。带着几个问题开始。</p><ul><li>Masonry是如何工作的？</li><li>链式调用的语法是如何实现的？</li><li>使用注意项？</li></ul><a id="more"></a><h3 id="工作流程">工作流程</h3><p>Masonry目录，红框内为主要类。<br><img src="/images/masonry_1.png" alt></p><p>MASConstraints:核心类，可以表示NSLayoutConstraint的信息，可以是一个或一组约束。分别对应两个子类MASViewConstraints，MASCompositeConstraint。链式调用的实现也来自这个类。下文分析。</p><p>MASViewConstraints:MASConstraints子类，包含一个约束的相关信息，first/second MASViewAttribute, layoutRelation。提供安装、卸载约束的方法。下文“约束”都指MASViewConstraints。</p><p>MASCompositeConstraint:MASConstraints子类，包含多个MASViewConstraints。下文称之为”约束集”。</p><p>MASViewAttribute:存储NSLayoutAttribute信息，和其对应的view。</p><p>MASConstraintMaker:如其名，这是一个maker(废话！)。这相当于一个发动机，负责生产约束，并让约束工作起来。</p><p>先看一段代码，这个我们再熟悉不过。mas_一敲，回车一按，调的就是它！</p><pre><code>- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block {    <span class="keyword">self</span><span class="variable">.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span>;    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];    block(constraintMaker);    <span class="keyword">return</span> [constraintMaker install];}</code></pre><p>Masonry工作入口在此，创建一个发动机MASConstraintMaker, block(constraintMaker)的作用则是创建约束。再看这个方法的调用：</p><pre><code><span class="collection">[topView mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">{    make.top.equalTo<span class="list">(<span class="keyword">self.view</span>)</span>.offSet<span class="list">(<span class="number">10</span>)</span><span class="comment">;</span>    make.left.right.equalTo<span class="list">(<span class="keyword">self.view</span>)</span><span class="comment">;</span>    make.bottom.equalTo<span class="list">(<span class="keyword">self.view</span>)</span><span class="comment">;</span>}</span>]</span><span class="comment">;</span></code></pre><p>make.bottom.equalTo(self.view)就是创建一条MASViewConstraints约束，make.left.right.equalTo(self.view)创建一条MASCompositeConstraint约束(包含两条MASViewConstraints约束)。结合上面两段代码看出，block(constraintMaker)就是通过maker创建约束，每条约束会存安装一条NSLayoutConstraint的所有信息(包括firsetItem, secondItem, firstAttribute, secondAttribute, layoutRelation, priority, constant等。)</p><p>接着看下make.top.equalTo(self.view)如何产生一条约束。make.top执行的三个函数。</p><pre><code>- (MASConstraint *)top {    <span class="keyword">return</span> [self <span class="string">addConstraintWithLayoutAttribute:</span>NSLayoutAttributeTop];}- (MASConstraint *)<span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute {    <span class="keyword">return</span> [self <span class="string">constraint:</span>nil <span class="string">addConstraintWithLayoutAttribute:</span>layoutAttribute];}- (MASConstraint *)<span class="string">constraint:</span>(MASConstraint *)constraint <span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute {    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] <span class="string">initWithView:</span>self.view <span class="string">layoutAttribute:</span>layoutAttribute];    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] <span class="string">initWithFirstViewAttribute:</span>viewAttribute];    <span class="keyword">if</span> ([constraint <span class="string">isKindOfClass:</span>MASViewConstraint.<span class="keyword">class</span>]) {        <span class="comment">//replace with composite constraint</span>        NSArray *children = @[constraint, newConstraint];        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] <span class="string">initWithChildren:</span>children];        compositeConstraint.delegate = self;        [self <span class="string">constraint:</span>constraint <span class="string">shouldBeReplacedWithConstraint:</span>compositeConstraint];        <span class="keyword">return</span> compositeConstraint;    }    <span class="keyword">if</span> (!constraint) {        newConstraint.delegate = self;        [self.constraints <span class="string">addObject:</span>newConstraint];    }    <span class="keyword">return</span> newConstraint;}</code></pre><p>看得出最终return 的是newConstraint，一个MASViewConstraint。大致过程：创建一个包含view是firstItem，attribute是NSLayoutAttributeTop的MASViewAttribute，再通过这个MASViewAttribute创建一个约束。并返回这个约束。这里有个重要信息, 不管创建的是约束或者约束集，它们都有个delegate指向maker。这是后面链式语法的关键点。另一个没那么重要信息是Masonry只在这个地方创建约束或约束集。make.top执行完毕，返回一个约束，接着看看.equalTo做了什么。</p><pre><code>- (MASConstraint * (^)(<span class="keyword">id</span>))equalTo {    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) {        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.equalToWithRelation</span>(attribute, <span class="built_in">NSLayoutRelationEqual</span>);    };}- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation {    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) {        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span><span class="variable">.class</span>]) {            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span><span class="variable">.hasLayoutRelation</span>, <span class="string">@"Redefinition of constraint relation"</span>);            <span class="built_in">NSMutableArray</span> *children = <span class="built_in">NSMutableArray</span><span class="variable">.new</span>;            <span class="keyword">for</span> (<span class="keyword">id</span> attr <span class="keyword">in</span> attribute) {                MASViewConstraint *viewConstraint = [<span class="keyword">self</span> <span class="keyword">copy</span>];                viewConstraint<span class="variable">.secondViewAttribute</span> = attr;                [children addObject:viewConstraint];            }            MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];            compositeConstraint<span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.delegate</span>;            [<span class="keyword">self</span><span class="variable">.delegate</span> constraint:<span class="keyword">self</span> shouldBeReplacedWithConstraint:compositeConstraint];            <span class="keyword">return</span> compositeConstraint;        } <span class="keyword">else</span> {            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span><span class="variable">.hasLayoutRelation</span> || <span class="keyword">self</span><span class="variable">.layoutRelation</span> == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span><span class="variable">.class</span>], <span class="string">@"Redefinition of constraint relation"</span>);            <span class="keyword">self</span><span class="variable">.layoutRelation</span> = relation;            <span class="keyword">self</span><span class="variable">.secondViewAttribute</span> = attribute;            <span class="keyword">return</span> <span class="keyword">self</span>;        }    };}</code></pre><p>两个函数，先看第一行和最后一行，第一行equalTo返回的是一个block，最后一行block中return self, 执行block返回的是就是self约束本身，有什么用？后面可以接着再用.offSet.priority等做其他设置。这里block怎么用的来着：供外界传入参数，在里头用参数进行一些设置，再返回约束本身，后面继续调用。（不管有多少参数要设置，都可以用这种参数一直.下去。）再看这个block里面做了什么事情，self.secondViewAttribute = attribute，设置约束的secondViewAttribute,(ps:这里传入的attribute是UIView，在setter函数里会自动生成一个真正attribute)。 这里设置了secondAttribute,那first哪里设置呢？回上面看一下maker生产第一个约束(initWithFirstViewAttribute:viewAttribute),那会设置了firstAttribute。最后的.offSet就是设置约束的constant的，返回约束本身。这里有个不明白点，这里.equalTo为什么要通过block来设置？像.offSet那样直接传入参数，返回self，不也可以？看着没什么差别。搞不懂block好处在哪…</p><p>另外，代码可以看出attribute也可以是数组，对应make.top.equalTo(@[self.view, otherView])这种用法，这种用法则会产生一个约束集。对约束集调用.offSet或者.equalTo, 就是取出约束集的每一个约束，都处理一遍。下面来看另一种情况，make.left.right.top.equalTo(self.view)。</p><p>从上分析得make.left产生一个firstItem为leftAttribute的约束，接下来就是”约束.right”会怎样？答案是，生成一个firstItem为rightAttribute的约束， 两个约束合成一个约束集。见代码：</p><pre><code>- (MASConstraint *)right {    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeRight</span>];}- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute {    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span><span class="variable">.hasLayoutRelation</span>, <span class="string">@"Attributes should be chained before defining the constraint relation"</span>);    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.delegate</span> constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];}</code></pre><p>这里self.delegate的就是maker，用maker创建rightAttribute约束，合成一个约束集。maker创建约束代码已经贴在上面。再看继续.top会怎样，代码：</p><pre><code>- (MASConstraint *)top {    return [<span class="keyword">self </span><span class="keyword">addConstraintWithLayoutAttribute:NSLayoutAttributeRight];</span>}- (MASConstraint *)<span class="keyword">addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute </span>{    [<span class="keyword">self </span>constraint:<span class="keyword">self </span><span class="keyword">addConstraintWithLayoutAttribute:layoutAttribute];</span>    return <span class="keyword">self;</span>}- (MASConstraint *)constraint:(MASConstraint __unused *)constraint <span class="keyword">addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute </span>{    id&lt;MASConstraintDelegate&gt; <span class="keyword">strongDelegate </span>= <span class="keyword">self.delegate;</span>    MASConstraint *newConstraint = [<span class="keyword">strongDelegate </span>constraint:<span class="keyword">self </span><span class="keyword">addConstraintWithLayoutAttribute:layoutAttribute];</span>    newConstraint.delegate = <span class="keyword">self;</span>    [<span class="keyword">self.childConstraints </span><span class="keyword">addObject:newConstraint];</span>    return newConstraint<span class="comment">;</span>}</code></pre><p>同样这里delegate就是maker，用maker创建一个约束，加入到这个约束集。最后make.left.right.top.equalTo(self.view)，.equalTo就是从约束集里一个个约束抓出来.equalTo一下就是了。</p><p>总结一下,共三个步骤：</p><ol><li>maker生产约束或约束集，方式是”maker.left”或”约束.right”(也就是:make.left.right),约束是通过delegate调用maker的生产方法。</li><li>约束信息设置，设置secondItem, layoutRelation, constant, priority，约束本身提供约束相关信息设置方法，方式是.equalTo, .offSet .priority, 约束集的相关信息设置就是遍历处理包含的约束。</li><li>maker生产完约束，install all就完了。方式：maker存有所有设置的约束，install本身的方法在约束类里，maker遍历执行。</li></ol><h2 id="链式调用语法如何实现？">链式调用语法如何实现？</h2><p>上面的分析，链式语法如何实现已经很清晰了。.left .right. equalTo. offset等都会返回约束本身或者一个约束集。约束或约束集又可以做下一次…的链式调用。信息的设置方式有.offSet(@1),就直接传值进去，还有.equalTo,通过block来传。</p><h2 id="使用注意事项？">使用注意事项？</h2><p>大量的Masonry使用，基本没出什么状况，是比较稳定的。有两个小问题要稍微注意下。</p><p>1、mas_updateConstraints,有遇到这个没生效的情况。看一下代码：</p><pre><code>- (<span class="keyword">void</span>)install {    ........此处省略若干代码........    MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.updateExisting</span>) {        existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];    }    <span class="keyword">if</span> (existingConstraint) {        <span class="comment">// just update the constant</span>        existingConstraint<span class="variable">.constant</span> = layoutConstraint<span class="variable">.constant</span>;        <span class="keyword">self</span><span class="variable">.layoutConstraint</span> = existingConstraint;    } <span class="keyword">else</span> {        [<span class="keyword">self</span><span class="variable">.installedView</span> addConstraint:layoutConstraint];        <span class="keyword">self</span><span class="variable">.layoutConstraint</span> = layoutConstraint;        [firstLayoutItem<span class="variable">.mas_installedConstraints</span> addObject:<span class="keyword">self</span>];    }}- (MASLayoutConstraint *)layoutConstraintSimilarTo:(MASLayoutConstraint *)layoutConstraint {    <span class="comment">// check if any constraints are the same apart from the only mutable property constant</span>    <span class="comment">// go through constraints in reverse as we do not want to match auto-resizing or interface builder constraints</span>    <span class="comment">// and they are likely to be added first.</span>    <span class="keyword">for</span> (<span class="built_in">NSLayoutConstraint</span> *existingConstraint <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.installedView</span><span class="variable">.constraints</span><span class="variable">.reverseObjectEnumerator</span>) {        <span class="keyword">if</span> (![existingConstraint isKindOfClass:MASLayoutConstraint<span class="variable">.class</span>]) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.firstItem</span> != layoutConstraint<span class="variable">.firstItem</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.secondItem</span> != layoutConstraint<span class="variable">.secondItem</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.firstAttribute</span> != layoutConstraint<span class="variable">.firstAttribute</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.secondAttribute</span> != layoutConstraint<span class="variable">.secondAttribute</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.relation</span> != layoutConstraint<span class="variable">.relation</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.multiplier</span> != layoutConstraint<span class="variable">.multiplier</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (existingConstraint<span class="variable">.priority</span> != layoutConstraint<span class="variable">.priority</span>) <span class="keyword">continue</span>;        <span class="keyword">return</span> (<span class="keyword">id</span>)existingConstraint;    }    <span class="keyword">return</span> <span class="literal">nil</span>;}</code></pre><p>更新过程：给个标志updateExisting，YES为需要更新，需要更新的话，就先找有没有相似的约束存在。有相似的约束就更新约束的constant。没有相似约束就添加新的约束。那么问题来了，那如何定义相似？看上面代码。就是firsetItem,secondItem,firstAttribute,secondAttribute,releation,multiplier,priority都相等就定义为相似，则更新constant即可。平时使用时update没生效是个什么情况？很有可能的就是multiplier,priority变了，或者同样效果的约束用了不同方式。比如：width设置，初始设置有可能是.equalTo(otherView), 然后数据源变了，需要刷新值，我们就理所当然的.equalTo(@55), 这样什么问题？sencondItem不一样，不仅不是update，还叠加了一个width约束上去,导致冲突，然后就懵逼了，wtf…..</p><p>2、命名问题。view.left, view.centerX, 最好不要用这个, 用view.mas_left, view.mas_centerX。 这种命名很容易冲突，经常会有一些库或者我们自己的代码，也给UIView加了category,用centerX,left,right什么的来取view的坐标。这种比较通用的命名尽量避免。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Overview&quot;&gt;Overview&lt;/h2&gt;&lt;p&gt;Masonry已经是离不开的开发库了，所有布局都用它，记录一下&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonary&lt;/a&gt;的源码学习。带着几个问题开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Masonry是如何工作的？&lt;/li&gt;
&lt;li&gt;链式调用的语法是如何实现的？&lt;/li&gt;
&lt;li&gt;使用注意项？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="masonry" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/masonry/"/>
    
      <category term="自动布局" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
      <category term="iOS源码学习" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/iOS%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS设备如何正确获取设备启动时间？</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/25/iOS%E8%AE%BE%E5%A4%87%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%EF%BC%9F/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/25/iOS设备如何正确获取设备启动时间？/</id>
    <published>2015-07-25T02:17:13.000Z</published>
    <updated>2019-10-27T08:25:41.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2><p>前段时间产品功能需求需要用到设备启动时间。找了几种方法，几番周折算是找到满足了需求的方法。此篇记录一下如何正确姿势获取设备启动时间。方法4是满足我需求的设备启动时间，可直接前往。</p><a id="more"></a><h3 id="方法1">方法1</h3><p>很容易找到这个方法：<code>[NSProcessInfo processInfo].systemUptime</code>。</p><p>官方文档：<em>The time interval since the computer was restarted. (read-only)</em>,<br>设备重新启动后的连续运行时间。乍一看很好，搞定。其实这个接口根本就不准。用了这个接口，你会发现即使你没有重新启动，设备启动时间却一直有在变化。短时间内似乎都是对的，但是设备启动个几天就有问题了。具体原因不详。</p><h3 id="方法2">方法2</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/sysctl.h&gt; </span><span class="preprocessor">#<span class="keyword">define</span> MIB_SIZE 2  </span><span class="keyword">int</span> mib[MIB_SIZE];<span class="keyword">size_t</span> size;<span class="keyword">struct</span> timeval  boottime;mib[<span class="number">0</span>] = CTL_KERN;mib[<span class="number">1</span>] = KERN_BOOTTIME;size = <span class="keyword">sizeof</span>(boottime);<span class="keyword">if</span> (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, <span class="number">0</span>) != -<span class="number">1</span>){    <span class="comment">// successful call</span>    NSDate* bootDate = [NSDate dateWithTimeIntervalSince1970:boottime.tv_sec];}</code></pre><p>上面代码来自<a href="http://stackoverflow.com/questions/10331020/get-the-boot-time-in-objective-c" target="_blank" rel="noopener">这里</a>。关键代码主要是sysctl，用来获取或设置内核状态的函数。sysctl及更多内核状态信息<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/sysctl.8.html" target="_blank" rel="noopener">戳这里</a>。上面代码就是直接读取内核状态中的设备启动时间。KERN_BOOTTIME点击进去头文件是这样描述的：/<em> struct: time kernel was booted </em>/。内核启动时间，这总靠谱了吧。经验证，这个时间是靠谱的。但是有个问题，如果改了设备时间，这个重启时间居然也跟着变…可见，这个参数的返回值是根据当前设备时间计算来的。一些需要准确判断重启时间的逻辑，显然在改变设备时间的状况下就有问题了。所以，不满足要求…</p><h3 id="方法3">方法3</h3><pre><code><span class="preprocessor">#include <span class="title">&lt;arpa/inet.h&gt;</span></span><span class="preprocessor">#include <span class="title">&lt;net/if.h&gt;</span></span><span class="preprocessor">#include <span class="title">&lt;ifaddrs.h&gt;</span></span><span class="preprocessor">#include <span class="title">&lt;net/if_dl.h&gt;</span></span><span class="built_in">BOOL</span>   success;<span class="keyword">struct</span> ifaddrs *addrs;<span class="keyword">const</span> <span class="keyword">struct</span> ifaddrs *cursor;<span class="keyword">const</span> <span class="keyword">struct</span> if_data *networkStatisc;<span class="built_in">NSString</span> *name=[[<span class="built_in">NSString</span> alloc]init];<span class="keyword">struct</span> IF_DATA_TIMEVAL changeTime ;success = getifaddrs(&amp;addrs) == <span class="number">0</span>;<span class="keyword">if</span> (success){    cursor = addrs;    <span class="keyword">while</span> (cursor != <span class="literal">NULL</span>)    {        name=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>,cursor-&gt;ifa_name];        <span class="keyword">if</span> (cursor-&gt;ifa_addr-&gt;sa_family == AF_LINK)        {            <span class="keyword">if</span> ([name hasPrefix:<span class="string">@"en1"</span>])            {                networkStatisc = (<span class="keyword">const</span> <span class="keyword">struct</span> if_data *) cursor-&gt;ifa_data;                changeTime = networkStatisc-&gt;ifi_lastchange;                <span class="built_in">NSDate</span> *restartTime = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:changeTime<span class="variable">.tv_sec</span>];            }            <span class="keyword">if</span> ([name hasPrefix:<span class="string">@"pdp_ip1"</span>])            {                networkStatisc = (<span class="keyword">const</span> <span class="keyword">struct</span> if_data *) cursor-&gt;ifa_data;                changeTime = networkStatisc-&gt;ifi_lastchange;                <span class="built_in">NSDate</span> *restartTime = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:changeTime<span class="variable">.tv_sec</span>];            }        }        cursor = cursor-&gt;ifa_next;    }    freeifaddrs(addrs);}</code></pre><p>上面代码是获取网络接口流量改变时间。 en开头的是WiFi网口，pdp_ip开头的是移动流量网口。有用到的是en0,和pdp_ip0,其他都是没用的（其实是不知道它什么时候会用到…）。设备重启会重置网络接口的数据，ifi_lastchange就会更新为重启的时间。对于en1、pdp_ip1就只在设备重启的时候改变，就可以作为设备重启时间。可惜的是，存在与方法2同样的问题，所以，不满足需求…</p><h3 id="方法4">方法4</h3><pre><code><span class="keyword">int</span> mib[<span class="number">4</span>] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, <span class="number">0</span>};size_t miblen = <span class="number">4</span>;size_t size;<span class="keyword">int</span> st = sysctl(mib, miblen, <span class="literal">NULL</span>, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="keyword">struct</span> kinfo_proc * process = <span class="literal">NULL</span>;<span class="keyword">struct</span> kinfo_proc * newprocess = <span class="literal">NULL</span>;<span class="keyword">do</span> {    size += size / <span class="number">10</span>;    newprocess = realloc(process, size);    <span class="keyword">if</span> (!newprocess){       <span class="keyword">if</span> (process)        {            free(process);        }        <span class="keyword">return</span> <span class="literal">nil</span>;    }    process = newprocess;    st = sysctl(mib, miblen, process, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>);} <span class="keyword">while</span> (st == -<span class="number">1</span> &amp;&amp; errno == ENOMEM);<span class="keyword">if</span> (st == <span class="number">0</span>){    <span class="keyword">if</span> (size % <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kinfo_proc) == <span class="number">0</span>){        <span class="keyword">int</span> nprocess = size / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kinfo_proc);        <span class="keyword">if</span> (nprocess)            {            <span class="built_in">NSMutableArray</span> * array = [[<span class="built_in">NSMutableArray</span> alloc] init];            <span class="keyword">for</span> (<span class="keyword">int</span> i = nprocess - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)            {                <span class="built_in">NSString</span> * processID = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%d"</span>, process[i]<span class="variable">.kp_proc</span><span class="variable">.p_pid</span>];                <span class="built_in">NSString</span> * processName = [[<span class="built_in">NSString</span> alloc]initWithBytes:(<span class="keyword">const</span> <span class="keyword">void</span> *)process[i]<span class="variable">.kp_proc</span><span class="variable">.p_comm</span>                                                                 length:strlen(process[i]<span class="variable">.kp_proc</span><span class="variable">.p_comm</span>)                                                               encoding:<span class="built_in">NSUTF8StringEncoding</span>];               <span class="keyword">if</span> ([processName isEqualToString:<span class="string">@"kernel_task"</span>])                 {                    <span class="built_in">NSTimeInterval</span> time = process[i]<span class="variable">.kp_proc</span><span class="variable">.p_un</span><span class="variable">.__p_starttime</span><span class="variable">.tv_sec</span>;                    ;                }            }            free(process);            <span class="keyword">return</span> array;        }    }}    </code></pre><p>上面代码做俩个事：1、获取正在运行进程列表。2、找到kernel_task进程，kernel_task进程的启动时间就可作为设备重启的时间。经测试，没有方法2、3的问题。满足要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Overview&quot;&gt;Overview&lt;/h2&gt;&lt;p&gt;前段时间产品功能需求需要用到设备启动时间。找了几种方法，几番周折算是找到满足了需求的方法。此篇记录一下如何正确姿势获取设备启动时间。方法4是满足我需求的设备启动时间，可直接前往。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/iOS/"/>
    
      <category term="设备启动时间" scheme="https://github.com/zhuangxq/zhuangxq.github.io.git/tags/%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>开篇！</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/07/%E5%BC%80%E7%AF%87%EF%BC%81/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/07/开篇！/</id>
    <published>2015-07-07T13:37:17.000Z</published>
    <updated>2015-07-07T15:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总算可以写上东西了。">总算可以写上东西了。</h2><p>   花了一个晚上部署，半个晚上换主题改七改八，hexo问题还是很多啊。不过想想hexo来自于学生之手，也是叼得不行啊。搭个blog好像十年前在玩QQ空间似的，好玩！感谢hexo作者，感谢yillia主题作者。这里就用来记录学习成长的点滴了（Markdown赶紧熟悉一下-。-）。玩的愉快~！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总算可以写上东西了。&quot;&gt;总算可以写上东西了。&lt;/h2&gt;&lt;p&gt;   花了一个晚上部署，半个晚上换主题改七改八，hexo问题还是很多啊。不过想想hexo来自于学生之手，也是叼得不行啊。搭个blog好像十年前在玩QQ空间似的，好玩！感谢hexo作者，感谢yillia主题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/06/hello-world/"/>
    <id>https://github.com/zhuangxq/zhuangxq.github.io.git/2015/07/06/hello-world/</id>
    <published>2015-07-06T13:20:49.000Z</published>
    <updated>2015-07-06T13:20:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
      
    
    </summary>
    
    
  </entry>
  
</feed>
